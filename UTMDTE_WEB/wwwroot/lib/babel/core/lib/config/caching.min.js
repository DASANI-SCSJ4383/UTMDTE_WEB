/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/@babel/core@7.17.5/lib/config/caching.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
"use strict";function _gensync(){const e=require("gensync");return _gensync=function(){return e},e}Object.defineProperty(exports,"__esModule",{value:!0}),exports.assertSimpleType=assertSimpleType,exports.makeStrongCache=makeStrongCache,exports.makeStrongCacheSync=makeStrongCacheSync,exports.makeWeakCache=makeWeakCache,exports.makeWeakCacheSync=makeWeakCacheSync;var _async=require("../gensync-utils/async"),_util=require("./util");const synchronize=e=>_gensync()(e).sync;function*genTrue(){return!0}function makeWeakCache(e){return makeCachedFunction(WeakMap,e)}function makeWeakCacheSync(e){return synchronize(makeWeakCache(e))}function makeStrongCache(e){return makeCachedFunction(Map,e)}function makeStrongCacheSync(e){return synchronize(makeStrongCache(e))}function makeCachedFunction(e,n){const r=new e,t=new e,a=new e;return function*(e,i){const o=yield*(0,_async.isAsync)(),s=o?t:r,c=yield*getCachedValueOrWait(o,s,a,e,i);if(c.valid)return c.value;const u=new CacheConfigurator(i),h=n(e,u);let l,d;if((0,_util.isIterableIterator)(h)){const n=h;d=yield*(0,_async.onFirstPause)(n,(()=>{l=setupAsyncLocks(u,a,e)}))}else d=h;return updateFunctionCache(s,u,e,d),l&&(a.delete(e),l.release(d)),d}}function*getCachedValue(e,n,r){const t=e.get(n);if(t)for(const{value:e,valid:n}of t)if(yield*n(r))return{valid:!0,value:e};return{valid:!1,value:null}}function*getCachedValueOrWait(e,n,r,t,a){const i=yield*getCachedValue(n,t,a);if(i.valid)return i;if(e){const e=yield*getCachedValue(r,t,a);if(e.valid){return{valid:!0,value:yield*(0,_async.waitFor)(e.value.promise)}}}return{valid:!1,value:null}}function setupAsyncLocks(e,n,r){const t=new Lock;return updateFunctionCache(n,e,r,t),t}function updateFunctionCache(e,n,r,t){n.configured()||n.forever();let a=e.get(r);switch(n.deactivate(),n.mode()){case"forever":a=[{value:t,valid:genTrue}],e.set(r,a);break;case"invalidate":a=[{value:t,valid:n.validator()}],e.set(r,a);break;case"valid":a?a.push({value:t,valid:n.validator()}):(a=[{value:t,valid:n.validator()}],e.set(r,a))}}class CacheConfigurator{constructor(e){this._active=!0,this._never=!1,this._forever=!1,this._invalidate=!1,this._configured=!1,this._pairs=[],this._data=void 0,this._data=e}simple(){return makeSimpleConfigurator(this)}mode(){return this._never?"never":this._forever?"forever":this._invalidate?"invalidate":"valid"}forever(){if(!this._active)throw new Error("Cannot change caching after evaluation has completed.");if(this._never)throw new Error("Caching has already been configured with .never()");this._forever=!0,this._configured=!0}never(){if(!this._active)throw new Error("Cannot change caching after evaluation has completed.");if(this._forever)throw new Error("Caching has already been configured with .forever()");this._never=!0,this._configured=!0}using(e){if(!this._active)throw new Error("Cannot change caching after evaluation has completed.");if(this._never||this._forever)throw new Error("Caching has already been configured with .never or .forever()");this._configured=!0;const n=e(this._data),r=(0,_async.maybeAsync)(e,"You appear to be using an async cache handler, but Babel has been called synchronously");return(0,_async.isThenable)(n)?n.then((e=>(this._pairs.push([e,r]),e))):(this._pairs.push([n,r]),n)}invalidate(e){return this._invalidate=!0,this.using(e)}validator(){const e=this._pairs;return function*(n){for(const[r,t]of e)if(r!==(yield*t(n)))return!1;return!0}}deactivate(){this._active=!1}configured(){return this._configured}}function makeSimpleConfigurator(e){function n(n){if("boolean"!=typeof n)return e.using((()=>assertSimpleType(n())));n?e.forever():e.never()}return n.forever=()=>e.forever(),n.never=()=>e.never(),n.using=n=>e.using((()=>assertSimpleType(n()))),n.invalidate=n=>e.invalidate((()=>assertSimpleType(n()))),n}function assertSimpleType(e){if((0,_async.isThenable)(e))throw new Error("You appear to be using an async cache handler, which your current version of Babel does not support. We may add support for this in the future, but if you're on the most recent version of @babel/core and still seeing this error, then you'll need to synchronously handle your caching logic.");if(null!=e&&"string"!=typeof e&&"boolean"!=typeof e&&"number"!=typeof e)throw new Error("Cache keys must be either string, boolean, number, null, or undefined.");return e}class Lock{constructor(){this.released=!1,this.promise=void 0,this._resolve=void 0,this.promise=new Promise((e=>{this._resolve=e}))}release(e){this.released=!0,this._resolve(e)}}
//# sourceMappingURL=/sm/07254bed2a85b5c65e1d7eb236c45f8df38e921f4531bd4dfaea8a0e92e03afe.map