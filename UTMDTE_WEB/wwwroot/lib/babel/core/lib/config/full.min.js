/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/@babel/core@7.17.5/lib/config/full.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
"use strict";function _gensync(){const e=require("gensync");return _gensync=function(){return e},e}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var _async=require("../gensync-utils/async"),_util=require("./util"),context=require("../index"),_plugin=require("./plugin"),_item=require("./item"),_configChain=require("./config-chain"),_deepArray=require("./helpers/deep-array");function _traverse(){const e=require("@babel/traverse");return _traverse=function(){return e},e}var _caching=require("./caching"),_options=require("./validation/options"),_plugins=require("./validation/plugins"),_configApi=require("./helpers/config-api"),_partial=require("./partial"),Context=require("./cache-contexts"),_default=_gensync()((function*(e){var n;const i=yield*(0,_partial.default)(e);if(!i)return null;const{options:t,context:r,fileHandling:s}=i;if("ignored"===s)return null;const a={},{plugins:o,presets:l}=t;if(!o||!l)throw new Error("Assertion failure - plugins and presets exist");const c=Object.assign({},r,{targets:t.targets}),p=e=>{const n=(0,_item.getItemDescriptor)(e);if(!n)throw new Error("Assertion failure - must be config item");return n},u=l.map(p),d=o.map(p),f=[[]],h=[],g=[],m=yield*enhanceError(r,(function*e(n,i){const t=[];for(let e=0;e<n.length;e++){const s=n[e];if(!1!==s.options){try{var r=yield*loadPresetDescriptor(s,c)}catch(i){throw"BABEL_UNKNOWN_OPTION"===i.code&&(0,_options.checkNoUnwrappedItemOptionPairs)(n,e,"preset",i),i}g.push(r.externalDependencies),s.ownPass?t.push({preset:r.chain,pass:[]}):t.unshift({preset:r.chain,pass:i})}}if(t.length>0){f.splice(1,0,...t.map((e=>e.pass)).filter((e=>e!==i)));for(const{preset:n,pass:i}of t){if(!n)return!0;i.push(...n.plugins);if(yield*e(n.presets,i))return!0;n.options.forEach((e=>{(0,_util.mergeOptions)(a,e)}))}}}))(u,f[0]);if(m)return null;const y=a;(0,_util.mergeOptions)(y,t);const v=Object.assign({},c,{assumptions:null!=(n=y.assumptions)?n:{}});return yield*enhanceError(r,(function*(){f[0].unshift(...d);for(const n of f){const i=[];h.push(i);for(let t=0;t<n.length;t++){const r=n[t];if(!1!==r.options){try{var e=yield*loadPluginDescriptor(r,v)}catch(e){throw"BABEL_UNKNOWN_PLUGIN_PROPERTY"===e.code&&(0,_options.checkNoUnwrappedItemOptionPairs)(n,t,"plugin",e),e}i.push(e),g.push(e.externalDependencies)}}}}))(),y.plugins=h[0],y.presets=h.slice(1).filter((e=>e.length>0)).map((e=>({plugins:e}))),y.passPerPreset=y.presets.length>0,{options:y,passes:h,externalDependencies:(0,_deepArray.finalize)(g)}}));function enhanceError(e,n){return function*(i,t){try{return yield*n(i,t)}catch(n){throw/^\[BABEL\]/.test(n.message)||(n.message=`[BABEL] ${e.filename||"unknown"}: ${n.message}`),n}}}exports.default=_default;const makeDescriptorLoader=e=>(0,_caching.makeWeakCache)((function*({value:n,options:i,dirname:t,alias:r},s){if(!1===i)throw new Error("Assertion failure");i=i||{};const a=[];let o=n;if("function"==typeof n){const l=(0,_async.maybeAsync)(n,"You appear to be using an async plugin/preset, but Babel has been called synchronously"),c=Object.assign({},context,e(s,a));try{o=yield*l(c,i,t)}catch(e){throw r&&(e.message+=` (While processing: ${JSON.stringify(r)})`),e}}if(!o||"object"!=typeof o)throw new Error("Plugin/Preset did not return an object.");if((0,_async.isThenable)(o))throw yield*[],new Error(`You appear to be using a promise as a plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version. As an alternative, you can prefix the promise with "await". (While processing: ${JSON.stringify(r)})`);if(a.length>0&&(!s.configured()||"forever"===s.mode())){let e=`A plugin/preset has external untracked dependencies (${a[0]}), but the cache `;throw s.configured()?e+=" has been configured to never be invalidated. ":e+="has not been configured to be invalidated when the external dependencies change. ",e+=`Plugins/presets should configure their cache to be invalidated when the external dependencies change, for example using \`api.cache.invalidate(() => statSync(filepath).mtimeMs)\` or \`api.cache.never()\`\n(While processing: ${JSON.stringify(r)})`,new Error(e)}return{value:o,options:i,dirname:t,alias:r,externalDependencies:(0,_deepArray.finalize)(a)}})),pluginDescriptorLoader=makeDescriptorLoader(_configApi.makePluginAPI),presetDescriptorLoader=makeDescriptorLoader(_configApi.makePresetAPI);function*loadPluginDescriptor(e,n){if(e.value instanceof _plugin.default){if(e.options)throw new Error("Passed options to an existing Plugin instance will not work.");return e.value}return yield*instantiatePlugin(yield*pluginDescriptorLoader(e,n),n)}const instantiatePlugin=(0,_caching.makeWeakCache)((function*({value:e,options:n,dirname:i,alias:t,externalDependencies:r},s){const a=(0,_plugins.validatePluginObject)(e),o=Object.assign({},a);if(o.visitor&&(o.visitor=_traverse().default.explode(Object.assign({},o.visitor))),o.inherits){const e={name:void 0,alias:`${t}$inherits`,value:o.inherits,options:n,dirname:i},a=yield*(0,_async.forwardAsync)(loadPluginDescriptor,(n=>s.invalidate((i=>n(e,i)))));o.pre=chain(a.pre,o.pre),o.post=chain(a.post,o.post),o.manipulateOptions=chain(a.manipulateOptions,o.manipulateOptions),o.visitor=_traverse().default.visitors.merge([a.visitor||{},o.visitor||{}]),a.externalDependencies.length>0&&(r=0===r.length?a.externalDependencies:(0,_deepArray.finalize)([r,a.externalDependencies]))}return new _plugin.default(o,n,t,r)})),validateIfOptionNeedsFilename=(e,n)=>{if(e.test||e.include||e.exclude){const e=n.name?`"${n.name}"`:"/* your preset */";throw new Error([`Preset ${e} requires a filename to be set when babel is called directly,`,"```",`babel.transform(code, { filename: 'file.ts', presets: [${e}] });`,"```","See https://babeljs.io/docs/en/options#filename for more information."].join("\n"))}},validatePreset=(e,n,i)=>{if(!n.filename){const{options:n}=e;validateIfOptionNeedsFilename(n,i),n.overrides&&n.overrides.forEach((e=>validateIfOptionNeedsFilename(e,i)))}};function*loadPresetDescriptor(e,n){const i=instantiatePreset(yield*presetDescriptorLoader(e,n));return validatePreset(i,n,e),{chain:yield*(0,_configChain.buildPresetChain)(i,n),externalDependencies:i.externalDependencies}}const instantiatePreset=(0,_caching.makeWeakCacheSync)((({value:e,dirname:n,alias:i,externalDependencies:t})=>({options:(0,_options.validate)("preset",e),alias:i,dirname:n,externalDependencies:t})));function chain(e,n){const i=[e,n].filter(Boolean);return i.length<=1?i[0]:function(...e){for(const n of i)n.apply(this,e)}}
//# sourceMappingURL=/sm/413e6eac231417727f2f88da93a0ae7acfbf09d93d2b75526208689fe76e9bb7.map