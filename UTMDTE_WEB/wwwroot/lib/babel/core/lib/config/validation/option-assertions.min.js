/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/@babel/core@7.17.5/lib/config/validation/option-assertions.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
"use strict";function _helperCompilationTargets(){const e=require("@babel/helper-compilation-targets");return _helperCompilationTargets=function(){return e},e}Object.defineProperty(exports,"__esModule",{value:!0}),exports.access=access,exports.assertArray=assertArray,exports.assertAssumptions=assertAssumptions,exports.assertBabelrcSearch=assertBabelrcSearch,exports.assertBoolean=assertBoolean,exports.assertCallerMetadata=assertCallerMetadata,exports.assertCompact=assertCompact,exports.assertConfigApplicableTest=assertConfigApplicableTest,exports.assertConfigFileSearch=assertConfigFileSearch,exports.assertFunction=assertFunction,exports.assertIgnoreList=assertIgnoreList,exports.assertInputSourceMap=assertInputSourceMap,exports.assertObject=assertObject,exports.assertPluginList=assertPluginList,exports.assertRootMode=assertRootMode,exports.assertSourceMaps=assertSourceMaps,exports.assertSourceType=assertSourceType,exports.assertString=assertString,exports.assertTargets=assertTargets,exports.msg=msg;var _options=require("./options");function msg(e){switch(e.type){case"root":return"";case"env":return`${msg(e.parent)}.env["${e.name}"]`;case"overrides":return`${msg(e.parent)}.overrides[${e.index}]`;case"option":return`${msg(e.parent)}.${e.name}`;case"access":return`${msg(e.parent)}[${JSON.stringify(e.name)}]`;default:throw new Error(`Assertion failure: Unknown type ${e.type}`)}}function access(e,r){return{type:"access",name:r,parent:e}}function assertRootMode(e,r){if(void 0!==r&&"root"!==r&&"upward"!==r&&"upward-optional"!==r)throw new Error(`${msg(e)} must be a "root", "upward", "upward-optional" or undefined`);return r}function assertSourceMaps(e,r){if(void 0!==r&&"boolean"!=typeof r&&"inline"!==r&&"both"!==r)throw new Error(`${msg(e)} must be a boolean, "inline", "both", or undefined`);return r}function assertCompact(e,r){if(void 0!==r&&"boolean"!=typeof r&&"auto"!==r)throw new Error(`${msg(e)} must be a boolean, "auto", or undefined`);return r}function assertSourceType(e,r){if(void 0!==r&&"module"!==r&&"script"!==r&&"unambiguous"!==r)throw new Error(`${msg(e)} must be "module", "script", "unambiguous", or undefined`);return r}function assertCallerMetadata(e,r){const t=assertObject(e,r);if(t){if("string"!=typeof t.name)throw new Error(`${msg(e)} set but does not contain "name" property string`);for(const r of Object.keys(t)){const s=access(e,r),o=t[r];if(null!=o&&"boolean"!=typeof o&&"string"!=typeof o&&"number"!=typeof o)throw new Error(`${msg(s)} must be null, undefined, a boolean, a string, or a number.`)}}return r}function assertInputSourceMap(e,r){if(void 0!==r&&"boolean"!=typeof r&&("object"!=typeof r||!r))throw new Error(`${msg(e)} must be a boolean, object, or undefined`);return r}function assertString(e,r){if(void 0!==r&&"string"!=typeof r)throw new Error(`${msg(e)} must be a string, or undefined`);return r}function assertFunction(e,r){if(void 0!==r&&"function"!=typeof r)throw new Error(`${msg(e)} must be a function, or undefined`);return r}function assertBoolean(e,r){if(void 0!==r&&"boolean"!=typeof r)throw new Error(`${msg(e)} must be a boolean, or undefined`);return r}function assertObject(e,r){if(void 0!==r&&("object"!=typeof r||Array.isArray(r)||!r))throw new Error(`${msg(e)} must be an object, or undefined`);return r}function assertArray(e,r){if(null!=r&&!Array.isArray(r))throw new Error(`${msg(e)} must be an array, or undefined`);return r}function assertIgnoreList(e,r){const t=assertArray(e,r);return t&&t.forEach(((r,t)=>assertIgnoreItem(access(e,t),r))),t}function assertIgnoreItem(e,r){if("string"!=typeof r&&"function"!=typeof r&&!(r instanceof RegExp))throw new Error(`${msg(e)} must be an array of string/Function/RegExp values, or undefined`);return r}function assertConfigApplicableTest(e,r){if(void 0===r)return r;if(Array.isArray(r))r.forEach(((r,t)=>{if(!checkValidTest(r))throw new Error(`${msg(access(e,t))} must be a string/Function/RegExp.`)}));else if(!checkValidTest(r))throw new Error(`${msg(e)} must be a string/Function/RegExp, or an array of those`);return r}function checkValidTest(e){return"string"==typeof e||"function"==typeof e||e instanceof RegExp}function assertConfigFileSearch(e,r){if(void 0!==r&&"boolean"!=typeof r&&"string"!=typeof r)throw new Error(`${msg(e)} must be a undefined, a boolean, a string, got ${JSON.stringify(r)}`);return r}function assertBabelrcSearch(e,r){if(void 0===r||"boolean"==typeof r)return r;if(Array.isArray(r))r.forEach(((r,t)=>{if(!checkValidTest(r))throw new Error(`${msg(access(e,t))} must be a string/Function/RegExp.`)}));else if(!checkValidTest(r))throw new Error(`${msg(e)} must be a undefined, a boolean, a string/Function/RegExp or an array of those, got ${JSON.stringify(r)}`);return r}function assertPluginList(e,r){const t=assertArray(e,r);return t&&t.forEach(((r,t)=>assertPluginItem(access(e,t),r))),t}function assertPluginItem(e,r){if(Array.isArray(r)){if(0===r.length)throw new Error(`${msg(e)} must include an object`);if(r.length>3)throw new Error(`${msg(e)} may only be a two-tuple or three-tuple`);if(assertPluginTarget(access(e,0),r[0]),r.length>1){const t=r[1];if(void 0!==t&&!1!==t&&("object"!=typeof t||Array.isArray(t)||null===t))throw new Error(`${msg(access(e,1))} must be an object, false, or undefined`)}if(3===r.length){const t=r[2];if(void 0!==t&&"string"!=typeof t)throw new Error(`${msg(access(e,2))} must be a string, or undefined`)}}else assertPluginTarget(e,r);return r}function assertPluginTarget(e,r){if(("object"!=typeof r||!r)&&"string"!=typeof r&&"function"!=typeof r)throw new Error(`${msg(e)} must be a string, object, function`);return r}function assertTargets(e,r){if((0,_helperCompilationTargets().isBrowsersQueryValid)(r))return r;if("object"!=typeof r||!r||Array.isArray(r))throw new Error(`${msg(e)} must be a string, an array of strings or an object`);const t=access(e,"browsers"),s=access(e,"esmodules");assertBrowsersList(t,r.browsers),assertBoolean(s,r.esmodules);for(const t of Object.keys(r)){const s=r[t],o=access(e,t);if("esmodules"===t)assertBoolean(o,s);else if("browsers"===t)assertBrowsersList(o,s);else{if(!Object.hasOwnProperty.call(_helperCompilationTargets().TargetNames,t)){const e=Object.keys(_helperCompilationTargets().TargetNames).join(", ");throw new Error(`${msg(o)} is not a valid target. Supported targets are ${e}`)}assertBrowserVersion(o,s)}}return r}function assertBrowsersList(e,r){if(void 0!==r&&!(0,_helperCompilationTargets().isBrowsersQueryValid)(r))throw new Error(`${msg(e)} must be undefined, a string or an array of strings`)}function assertBrowserVersion(e,r){if(("number"!=typeof r||Math.round(r)!==r)&&"string"!=typeof r)throw new Error(`${msg(e)} must be a string or an integer number`)}function assertAssumptions(e,r){if(void 0===r)return;if("object"!=typeof r||null===r)throw new Error(`${msg(e)} must be an object or undefined.`);let t=e;do{t=t.parent}while("root"!==t.type);const s="preset"===t.source;for(const t of Object.keys(r)){const o=access(e,t);if(!_options.assumptionsNames.has(t))throw new Error(`${msg(o)} is not a supported assumption.`);if("boolean"!=typeof r[t])throw new Error(`${msg(o)} must be a boolean.`);if(s&&!1===r[t])throw new Error(`${msg(o)} cannot be set to 'false' inside presets.`)}return r}
//# sourceMappingURL=/sm/7af0d9e79cdb3d10de640de9d973fe378476a58b9ca6c21e68717425e0267598.map