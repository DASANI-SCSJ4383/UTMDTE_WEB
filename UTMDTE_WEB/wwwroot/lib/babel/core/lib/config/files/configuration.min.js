/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/@babel/core@7.17.5/lib/config/files/configuration.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
"use strict";function _debug(){const e=require("debug");return _debug=function(){return e},e}function _fs(){const e=require("fs");return _fs=function(){return e},e}function _path(){const e=require("path");return _path=function(){return e},e}function _json(){const e=require("json5");return _json=function(){return e},e}function _gensync(){const e=require("gensync");return _gensync=function(){return e},e}Object.defineProperty(exports,"__esModule",{value:!0}),exports.ROOT_CONFIG_FILENAMES=void 0,exports.findConfigUpwards=findConfigUpwards,exports.findRelativeConfig=findRelativeConfig,exports.findRootConfig=findRootConfig,exports.loadConfig=loadConfig,exports.resolveShowConfigPath=resolveShowConfigPath;var _caching=require("../caching"),_configApi=require("../helpers/config-api"),_utils=require("./utils"),_moduleTypes=require("./module-types"),_patternToRegex=require("../pattern-to-regex"),fs=require("../../gensync-utils/fs");function _module(){const e=require("module");return _module=function(){return e},e}const debug=_debug()("babel:config:loading:files:configuration"),ROOT_CONFIG_FILENAMES=["babel.config.js","babel.config.cjs","babel.config.mjs","babel.config.json"];exports.ROOT_CONFIG_FILENAMES=ROOT_CONFIG_FILENAMES;const RELATIVE_CONFIG_FILENAMES=[".babelrc",".babelrc.js",".babelrc.cjs",".babelrc.mjs",".babelrc.json"],BABELIGNORE_FILENAME=".babelignore";function findConfigUpwards(e){let n=e;for(;;){for(const e of ROOT_CONFIG_FILENAMES)if(_fs().existsSync(_path().join(n,e)))return n;const e=_path().dirname(n);if(n===e)break;n=e}return null}function*findRelativeConfig(e,n,o){let r=null,i=null;const t=_path().dirname(e.filepath);for(const s of e.directories){var a;if(!r)r=yield*loadOneConfig(RELATIVE_CONFIG_FILENAMES,s,n,o,(null==(a=e.pkg)?void 0:a.dirname)===s?packageToBabelConfig(e.pkg):null);if(!i){const e=_path().join(s,".babelignore");i=yield*readIgnoreConfig(e),i&&debug("Found ignore %o from %o.",i.filepath,t)}}return{config:r,ignore:i}}function findRootConfig(e,n,o){return loadOneConfig(ROOT_CONFIG_FILENAMES,e,n,o)}function*loadOneConfig(e,n,o,r,i=null){const t=(yield*_gensync().all(e.map((e=>readConfig(_path().join(n,e),o,r))))).reduce(((e,o)=>{if(o&&e)throw new Error(`Multiple configuration files found. Please remove one:\n - ${_path().basename(e.filepath)}\n - ${o.filepath}\nfrom ${n}`);return o||e}),i);return t&&debug("Found configuration %o from %o.",t.filepath,n),t}function*loadConfig(e,n,o,r){const i=(t=process.versions.node,a="8.9",t=t.split("."),a=a.split("."),+t[0]>+a[0]||t[0]==a[0]&&+t[1]>=+a[1]?require.resolve:(e,{paths:[n]},o=require("module"))=>{let r=o._findPath(e,o._nodeModulePaths(n).concat(n));if(r)return r;throw r=new Error(`Cannot resolve module '${e}'`),r.code="MODULE_NOT_FOUND",r})(e,{paths:[n]});var t,a;const s=yield*readConfig(i,o,r);if(!s)throw new Error(`Config file ${i} contains no configuration data`);return debug("Loaded config %o from %o.",e,n),s}function readConfig(e,n,o){const r=_path().extname(e);return".js"===r||".cjs"===r||".mjs"===r?readConfigJS(e,{envName:n,caller:o}):readConfigJSON5(e)}const LOADING_CONFIGS=new Set,readConfigJS=(0,_caching.makeStrongCache)((function*(e,n){if(!_fs().existsSync(e))return n.never(),null;if(LOADING_CONFIGS.has(e))return n.never(),debug("Auto-ignoring usage of config %o.",e),{filepath:e,dirname:_path().dirname(e),options:{}};let o;try{LOADING_CONFIGS.add(e),o=yield*(0,_moduleTypes.default)(e,"You appear to be using a native ECMAScript module configuration file, which is only supported when running Babel asynchronously.")}catch(n){throw n.message=`${e}: Error while loading config - ${n.message}`,n}finally{LOADING_CONFIGS.delete(e)}let r=!1;if("function"==typeof o&&(yield*[],o=o((0,_configApi.makeConfigAPI)(n)),r=!0),!o||"object"!=typeof o||Array.isArray(o))throw new Error(`${e}: Configuration should be an exported JavaScript object.`);if("function"==typeof o.then)throw new Error("You appear to be using an async configuration, which your current version of Babel does not support. We may add support for this in the future, but if you're on the most recent version of @babel/core and still seeing this error, then you'll need to synchronously return your config.");return r&&!n.configured()&&throwConfigError(),{filepath:e,dirname:_path().dirname(e),options:o}})),packageToBabelConfig=(0,_caching.makeWeakCacheSync)((e=>{const n=e.options.babel;if(void 0===n)return null;if("object"!=typeof n||Array.isArray(n)||null===n)throw new Error(`${e.filepath}: .babel property must be an object`);return{filepath:e.filepath,dirname:e.dirname,options:n}})),readConfigJSON5=(0,_utils.makeStaticFileCache)(((e,n)=>{let o;try{o=_json().parse(n)}catch(n){throw n.message=`${e}: Error while parsing config - ${n.message}`,n}if(!o)throw new Error(`${e}: No config detected`);if("object"!=typeof o)throw new Error(`${e}: Config returned typeof ${typeof o}`);if(Array.isArray(o))throw new Error(`${e}: Expected config object but found array`);return delete o.$schema,{filepath:e,dirname:_path().dirname(e),options:o}})),readIgnoreConfig=(0,_utils.makeStaticFileCache)(((e,n)=>{const o=_path().dirname(e),r=n.split("\n").map((e=>e.replace(/#(.*?)$/,"").trim())).filter((e=>!!e));for(const e of r)if("!"===e[0])throw new Error("Negation of file paths is not supported.");return{filepath:e,dirname:_path().dirname(e),ignore:r.map((e=>(0,_patternToRegex.default)(e,o)))}}));function*resolveShowConfigPath(e){const n=process.env.BABEL_SHOW_CONFIG_FOR;if(null!=n){const o=_path().resolve(e,n);if(!(yield*fs.stat(o)).isFile())throw new Error(`${o}: BABEL_SHOW_CONFIG_FOR must refer to a regular file, directories are not supported.`);return o}return null}function throwConfigError(){throw new Error('Caching was left unconfigured. Babel\'s plugins, presets, and .babelrc.js files can be configured\nfor various types of caching, using the first param of their handler functions:\n\nmodule.exports = function(api) {\n  // The API exposes the following:\n\n  // Cache the returned value forever and don\'t call this function again.\n  api.cache(true);\n\n  // Don\'t cache at all. Not recommended because it will be very slow.\n  api.cache(false);\n\n  // Cached based on the value of some function. If this function returns a value different from\n  // a previously-encountered value, the plugins will re-evaluate.\n  var env = api.cache(() => process.env.NODE_ENV);\n\n  // If testing for a specific env, we recommend specifics to avoid instantiating a plugin for\n  // any possible NODE_ENV value that might come up during plugin execution.\n  var isProd = api.cache(() => process.env.NODE_ENV === "production");\n\n  // .cache(fn) will perform a linear search though instances to find the matching plugin based\n  // based on previous instantiated plugins. If you want to recreate the plugin and discard the\n  // previous instance whenever something changes, you may use:\n  var isProd = api.cache.invalidate(() => process.env.NODE_ENV === "production");\n\n  // Note, we also expose the following more-verbose versions of the above examples:\n  api.cache.forever(); // api.cache(true)\n  api.cache.never();   // api.cache(false)\n  api.cache.using(fn); // api.cache(fn)\n\n  // Return the value that will be cached.\n  return { };\n};')}
//# sourceMappingURL=/sm/7a461cdbd694761eb43b359b4e0d00d19be7b63820b3b93afc1fe8f3fb4b086c.map