/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/@babel/core@7.17.5/lib/config/files/plugins.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
"use strict";function _debug(){const e=require("debug");return _debug=function(){return e},e}function _path(){const e=require("path");return _path=function(){return e},e}function _gensync(){const e=require("gensync");return _gensync=function(){return e},e}Object.defineProperty(exports,"__esModule",{value:!0}),exports.loadPlugin=loadPlugin,exports.loadPreset=loadPreset,exports.resolvePlugin=resolvePlugin,exports.resolvePreset=resolvePreset;var _async=require("../../gensync-utils/async"),_moduleTypes=require("./module-types");function _url(){const e=require("url");return _url=function(){return e},e}var _importMetaResolve=require("./import-meta-resolve");function _module(){const e=require("module");return _module=function(){return e},e}function asyncGeneratorStep(e,r,t,n,o,a,l){try{var i=e[a](l),u=i.value}catch(e){return void t(e)}i.done?r(u):Promise.resolve(u).then(n,o)}function _asyncToGenerator(e){return function(){var r=this,t=arguments;return new Promise((function(n,o){var a=e.apply(r,t);function l(e){asyncGeneratorStep(a,n,o,l,i,"next",e)}function i(e){asyncGeneratorStep(a,n,o,l,i,"throw",e)}l(void 0)}))}}const debug=_debug()("babel:config:loading:files:plugins"),EXACT_RE=/^module:/,BABEL_PLUGIN_PREFIX_RE=/^(?!@|module:|[^/]+\/|babel-plugin-)/,BABEL_PRESET_PREFIX_RE=/^(?!@|module:|[^/]+\/|babel-preset-)/,BABEL_PLUGIN_ORG_RE=/^(@babel\/)(?!plugin-|[^/]+\/)/,BABEL_PRESET_ORG_RE=/^(@babel\/)(?!preset-|[^/]+\/)/,OTHER_PLUGIN_ORG_RE=/^(@(?!babel\/)[^/]+\/)(?![^/]*babel-plugin(?:-|\/|$)|[^/]+\/)/,OTHER_PRESET_ORG_RE=/^(@(?!babel\/)[^/]+\/)(?![^/]*babel-preset(?:-|\/|$)|[^/]+\/)/,OTHER_ORG_DEFAULT_RE=/^(@(?!babel$)[^/]+)$/;function*resolvePlugin(e,r){return yield*resolveStandardizedName("plugin",e,r)}function*resolvePreset(e,r){return yield*resolveStandardizedName("preset",e,r)}function*loadPlugin(e,r){const t=yield*resolvePlugin(e,r),n=yield*requireModule("plugin",t);return debug("Loaded plugin %o from %o.",e,r),{filepath:t,value:n}}function*loadPreset(e,r){const t=yield*resolvePreset(e,r),n=yield*requireModule("preset",t);return debug("Loaded preset %o from %o.",e,r),{filepath:t,value:n}}function standardizeName(e,r){if(_path().isAbsolute(r))return r;const t="preset"===e;return r.replace(t?BABEL_PRESET_PREFIX_RE:BABEL_PLUGIN_PREFIX_RE,`babel-${e}-`).replace(t?BABEL_PRESET_ORG_RE:BABEL_PLUGIN_ORG_RE,`$1${e}-`).replace(t?OTHER_PRESET_ORG_RE:OTHER_PLUGIN_ORG_RE,`$1babel-${e}-`).replace(OTHER_ORG_DEFAULT_RE,`$1/babel-${e}`).replace(EXACT_RE,"")}function*resolveAlternativesHelper(e,r){const t=standardizeName(e,r),{error:n,value:o}=yield t;if(!n)return o;if("MODULE_NOT_FOUND"!==n.code)throw n;t===r||(yield r).error||(n.message+=`\n- If you want to resolve "${r}", use "module:${r}"`),(yield standardizeName(e,"@babel/"+r)).error||(n.message+=`\n- Did you mean "@babel/${r}"?`);const a="preset"===e?"plugin":"preset";throw(yield standardizeName(a,r)).error||(n.message+=`\n- Did you accidentally pass a ${a} as a ${e}?`),n}function tryRequireResolve(e,{paths:[r]}){try{return{error:null,value:(t=process.versions.node,n="8.9",t=t.split("."),n=n.split("."),+t[0]>+n[0]||t[0]==n[0]&&+t[1]>=+n[1]?require.resolve:(e,{paths:[r]},t=require("module"))=>{let n=t._findPath(e,t._nodeModulePaths(r).concat(r));if(n)return n;throw n=new Error(`Cannot resolve module '${e}'`),n.code="MODULE_NOT_FOUND",n})(e,{paths:[r]})}}catch(e){return{error:e,value:null}}var t,n}function tryImportMetaResolve(e,r){return _tryImportMetaResolve.apply(this,arguments)}function _tryImportMetaResolve(){return(_tryImportMetaResolve=_asyncToGenerator((function*(e,r){try{return{error:null,value:yield(0,_importMetaResolve.default)(e,r)}}catch(e){return{error:e,value:null}}}))).apply(this,arguments)}function resolveStandardizedNameForRequrie(e,r,t){const n=resolveAlternativesHelper(e,r);let o=n.next();for(;!o.done;)o=n.next(tryRequireResolve(o.value,{paths:[t]}));return o.value}function resolveStandardizedNameForImport(e,r,t){return _resolveStandardizedNameForImport.apply(this,arguments)}function _resolveStandardizedNameForImport(){return(_resolveStandardizedNameForImport=_asyncToGenerator((function*(e,r,t){const n=(0,_url().pathToFileURL)(_path().join(t,"./babel-virtual-resolve-base.js")).href,o=resolveAlternativesHelper(e,r);let a=o.next();for(;!a.done;)a=o.next(yield tryImportMetaResolve(a.value,n));return(0,_url().fileURLToPath)(a.value)}))).apply(this,arguments)}const resolveStandardizedName=_gensync()({sync:(e,r,t=process.cwd())=>resolveStandardizedNameForRequrie(e,r,t),async:(e,r,t=process.cwd())=>_asyncToGenerator((function*(){if(!_moduleTypes.supportsESM)return resolveStandardizedNameForRequrie(e,r,t);try{return yield resolveStandardizedNameForImport(e,r,t)}catch(n){try{return resolveStandardizedNameForRequrie(e,r,t)}catch(e){if("MODULE_NOT_FOUND"===n.type)throw n;if("MODULE_NOT_FOUND"===e.type)throw e;throw n}}}))()});var LOADING_MODULES=new Set;function*requireModule(e,r){if(!(yield*(0,_async.isAsync)())&&LOADING_MODULES.has(r))throw new Error(`Reentrant ${e} detected trying to load "${r}". This module is not ignored and is trying to load itself while compiling itself, leading to a dependency cycle. We recommend adding it to your "ignore" list in your babelrc, or to a .babelignore.`);try{return LOADING_MODULES.add(r),yield*(0,_moduleTypes.default)(r,`You appear to be using a native ECMAScript module ${e}, which is only supported when running Babel asynchronously.`,!0)}catch(e){throw e.message=`[BABEL]: ${e.message} (While processing: ${r})`,e}finally{LOADING_MODULES.delete(r)}}
//# sourceMappingURL=/sm/db403217bbf2813f28b1b5c6311b7fa14da6f18163b52a91df3331cb85e0af98.map