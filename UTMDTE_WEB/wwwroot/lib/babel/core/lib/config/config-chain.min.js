/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/@babel/core@7.17.5/lib/config/config-chain.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
"use strict";function _path(){const e=require("path");return _path=function(){return e},e}function _debug(){const e=require("debug");return _debug=function(){return e},e}Object.defineProperty(exports,"__esModule",{value:!0}),exports.buildPresetChain=buildPresetChain,exports.buildPresetChainWalker=void 0,exports.buildRootChain=buildRootChain;var _options=require("./validation/options"),_patternToRegex=require("./pattern-to-regex"),_printer=require("./printer"),_files=require("./files"),_caching=require("./caching"),_configDescriptors=require("./config-descriptors");const debug=_debug()("babel:config:config-chain");function*buildPresetChain(e,i){const r=yield*buildPresetChainWalker(e,i);return r?{plugins:dedupDescriptors(r.plugins),presets:dedupDescriptors(r.presets),options:r.options.map((e=>normalizeOptions(e))),files:new Set}:null}const buildPresetChainWalker=makeChainWalker({root:e=>loadPresetDescriptors(e),env:(e,i)=>loadPresetEnvDescriptors(e)(i),overrides:(e,i)=>loadPresetOverridesDescriptors(e)(i),overridesEnv:(e,i,r)=>loadPresetOverridesEnvDescriptors(e)(i)(r),createLogger:()=>()=>{}});exports.buildPresetChainWalker=buildPresetChainWalker;const loadPresetDescriptors=(0,_caching.makeWeakCacheSync)((e=>buildRootDescriptors(e,e.alias,_configDescriptors.createUncachedDescriptors))),loadPresetEnvDescriptors=(0,_caching.makeWeakCacheSync)((e=>(0,_caching.makeStrongCacheSync)((i=>buildEnvDescriptors(e,e.alias,_configDescriptors.createUncachedDescriptors,i))))),loadPresetOverridesDescriptors=(0,_caching.makeWeakCacheSync)((e=>(0,_caching.makeStrongCacheSync)((i=>buildOverrideDescriptors(e,e.alias,_configDescriptors.createUncachedDescriptors,i))))),loadPresetOverridesEnvDescriptors=(0,_caching.makeWeakCacheSync)((e=>(0,_caching.makeStrongCacheSync)((i=>(0,_caching.makeStrongCacheSync)((r=>buildOverrideEnvDescriptors(e,e.alias,_configDescriptors.createUncachedDescriptors,i,r)))))));function*buildRootChain(e,i){let r,n;const o=new _printer.ConfigPrinter,t=yield*loadProgrammaticChain({options:e,dirname:i.cwd},i,void 0,o);if(!t)return null;const s=yield*o.output();let a;"string"==typeof e.configFile?a=yield*(0,_files.loadConfig)(e.configFile,i.cwd,i.envName,i.caller):!1!==e.configFile&&(a=yield*(0,_files.findRootConfig)(i.root,i.envName,i.caller));let{babelrc:c,babelrcRoots:l}=e,d=i.cwd;const p=emptyChain(),u=new _printer.ConfigPrinter;if(a){const e=validateConfigFile(a),n=yield*loadFileChain(e,i,void 0,u);if(!n)return null;r=yield*u.output(),void 0===c&&(c=e.options.babelrc),void 0===l&&(d=e.dirname,l=e.options.babelrcRoots),mergeChain(p,n)}let f,g,h=!1;const v=emptyChain();if((!0===c||void 0===c)&&"string"==typeof i.filename){const e=yield*(0,_files.findPackageData)(i.filename);if(e&&babelrcLoadEnabled(i,e,l,d)){if(({ignore:f,config:g}=yield*(0,_files.findRelativeConfig)(e,i.envName,i.caller)),f&&v.files.add(f.filepath),f&&shouldIgnore(i,f.ignore,null,f.dirname)&&(h=!0),g&&!h){const e=validateBabelrcFile(g),r=new _printer.ConfigPrinter,o=yield*loadFileChain(e,i,void 0,r);o?(n=yield*r.output(),mergeChain(v,o)):h=!0}g&&h&&v.files.add(g.filepath)}}i.showConfig&&console.log(`Babel configs on "${i.filename}" (ascending priority):\n`+[r,n,s].filter((e=>!!e)).join("\n\n")+"\n-----End Babel configs-----");const m=mergeChain(mergeChain(mergeChain(emptyChain(),p),v),t);return{plugins:h?[]:dedupDescriptors(m.plugins),presets:h?[]:dedupDescriptors(m.presets),options:h?[]:m.options.map((e=>normalizeOptions(e))),fileHandling:h?"ignored":"transpile",ignore:f||void 0,babelrc:g||void 0,config:a||void 0,files:m.files}}function babelrcLoadEnabled(e,i,r,n){if("boolean"==typeof r)return r;const o=e.root;if(void 0===r)return-1!==i.directories.indexOf(o);let t=r;return Array.isArray(t)||(t=[t]),t=t.map((e=>"string"==typeof e?_path().resolve(n,e):e)),1===t.length&&t[0]===o?-1!==i.directories.indexOf(o):t.some((r=>("string"==typeof r&&(r=(0,_patternToRegex.default)(r,n)),i.directories.some((i=>matchPattern(r,n,i,e))))))}const validateConfigFile=(0,_caching.makeWeakCacheSync)((e=>({filepath:e.filepath,dirname:e.dirname,options:(0,_options.validate)("configfile",e.options)}))),validateBabelrcFile=(0,_caching.makeWeakCacheSync)((e=>({filepath:e.filepath,dirname:e.dirname,options:(0,_options.validate)("babelrcfile",e.options)}))),validateExtendFile=(0,_caching.makeWeakCacheSync)((e=>({filepath:e.filepath,dirname:e.dirname,options:(0,_options.validate)("extendsfile",e.options)}))),loadProgrammaticChain=makeChainWalker({root:e=>buildRootDescriptors(e,"base",_configDescriptors.createCachedDescriptors),env:(e,i)=>buildEnvDescriptors(e,"base",_configDescriptors.createCachedDescriptors,i),overrides:(e,i)=>buildOverrideDescriptors(e,"base",_configDescriptors.createCachedDescriptors,i),overridesEnv:(e,i,r)=>buildOverrideEnvDescriptors(e,"base",_configDescriptors.createCachedDescriptors,i,r),createLogger:(e,i,r)=>buildProgrammaticLogger(e,i,r)}),loadFileChainWalker=makeChainWalker({root:e=>loadFileDescriptors(e),env:(e,i)=>loadFileEnvDescriptors(e)(i),overrides:(e,i)=>loadFileOverridesDescriptors(e)(i),overridesEnv:(e,i,r)=>loadFileOverridesEnvDescriptors(e)(i)(r),createLogger:(e,i,r)=>buildFileLogger(e.filepath,i,r)});function*loadFileChain(e,i,r,n){const o=yield*loadFileChainWalker(e,i,r,n);return o&&o.files.add(e.filepath),o}const loadFileDescriptors=(0,_caching.makeWeakCacheSync)((e=>buildRootDescriptors(e,e.filepath,_configDescriptors.createUncachedDescriptors))),loadFileEnvDescriptors=(0,_caching.makeWeakCacheSync)((e=>(0,_caching.makeStrongCacheSync)((i=>buildEnvDescriptors(e,e.filepath,_configDescriptors.createUncachedDescriptors,i))))),loadFileOverridesDescriptors=(0,_caching.makeWeakCacheSync)((e=>(0,_caching.makeStrongCacheSync)((i=>buildOverrideDescriptors(e,e.filepath,_configDescriptors.createUncachedDescriptors,i))))),loadFileOverridesEnvDescriptors=(0,_caching.makeWeakCacheSync)((e=>(0,_caching.makeStrongCacheSync)((i=>(0,_caching.makeStrongCacheSync)((r=>buildOverrideEnvDescriptors(e,e.filepath,_configDescriptors.createUncachedDescriptors,i,r)))))));function buildFileLogger(e,i,r){return r?r.configure(i.showConfig,_printer.ChainFormatter.Config,{filepath:e}):()=>{}}function buildRootDescriptors({dirname:e,options:i},r,n){return n(e,i,r)}function buildProgrammaticLogger(e,i,r){var n;return r?r.configure(i.showConfig,_printer.ChainFormatter.Programmatic,{callerName:null==(n=i.caller)?void 0:n.name}):()=>{}}function buildEnvDescriptors({dirname:e,options:i},r,n,o){const t=i.env&&i.env[o];return t?n(e,t,`${r}.env["${o}"]`):null}function buildOverrideDescriptors({dirname:e,options:i},r,n,o){const t=i.overrides&&i.overrides[o];if(!t)throw new Error("Assertion failure - missing override");return n(e,t,`${r}.overrides[${o}]`)}function buildOverrideEnvDescriptors({dirname:e,options:i},r,n,o,t){const s=i.overrides&&i.overrides[o];if(!s)throw new Error("Assertion failure - missing override");const a=s.env&&s.env[t];return a?n(e,a,`${r}.overrides[${o}].env["${t}"]`):null}function makeChainWalker({root:e,env:i,overrides:r,overridesEnv:n,createLogger:o}){return function*(t,s,a=new Set,c){const{dirname:l}=t,d=[],p=e(t);if(configIsApplicable(p,l,s)){d.push({config:p,envName:void 0,index:void 0});const e=i(t,s.envName);e&&configIsApplicable(e,l,s)&&d.push({config:e,envName:s.envName,index:void 0}),(p.options.overrides||[]).forEach(((e,i)=>{const o=r(t,i);if(configIsApplicable(o,l,s)){d.push({config:o,index:i,envName:void 0});const e=n(t,i,s.envName);e&&configIsApplicable(e,l,s)&&d.push({config:e,index:i,envName:s.envName})}}))}if(d.some((({config:{options:{ignore:e,only:i}}})=>shouldIgnore(s,e,i,l))))return null;const u=emptyChain(),f=o(t,s,c);for(const{config:e,index:i,envName:r}of d){if(!(yield*mergeExtendsChain(u,e.options,l,s,a,c)))return null;f(e,i,r),yield*mergeChainOpts(u,e)}return u}}function*mergeExtendsChain(e,i,r,n,o,t){if(void 0===i.extends)return!0;const s=yield*(0,_files.loadConfig)(i.extends,r,n.envName,n.caller);if(o.has(s))throw new Error(`Configuration cycle detected loading ${s.filepath}.\nFile already loaded following the config chain:\n`+Array.from(o,(e=>` - ${e.filepath}`)).join("\n"));o.add(s);const a=yield*loadFileChain(validateExtendFile(s),n,o,t);return o.delete(s),!!a&&(mergeChain(e,a),!0)}function mergeChain(e,i){e.options.push(...i.options),e.plugins.push(...i.plugins),e.presets.push(...i.presets);for(const r of i.files)e.files.add(r);return e}function*mergeChainOpts(e,{options:i,plugins:r,presets:n}){return e.options.push(i),e.plugins.push(...yield*r()),e.presets.push(...yield*n()),e}function emptyChain(){return{options:[],presets:[],plugins:[],files:new Set}}function normalizeOptions(e){const i=Object.assign({},e);return delete i.extends,delete i.env,delete i.overrides,delete i.plugins,delete i.presets,delete i.passPerPreset,delete i.ignore,delete i.only,delete i.test,delete i.include,delete i.exclude,Object.prototype.hasOwnProperty.call(i,"sourceMap")&&(i.sourceMaps=i.sourceMap,delete i.sourceMap),i}function dedupDescriptors(e){const i=new Map,r=[];for(const n of e)if("function"==typeof n.value){const e=n.value;let o=i.get(e);o||(o=new Map,i.set(e,o));let t=o.get(n.name);t?t.value=n:(t={value:n},r.push(t),n.ownPass||o.set(n.name,t))}else r.push({value:n});return r.reduce(((e,i)=>(e.push(i.value),e)),[])}function configIsApplicable({options:e},i,r){return(void 0===e.test||configFieldIsApplicable(r,e.test,i))&&(void 0===e.include||configFieldIsApplicable(r,e.include,i))&&(void 0===e.exclude||!configFieldIsApplicable(r,e.exclude,i))}function configFieldIsApplicable(e,i,r){return matchesPatterns(e,Array.isArray(i)?i:[i],r)}function ignoreListReplacer(e,i){return i instanceof RegExp?String(i):i}function shouldIgnore(e,i,r,n){if(i&&matchesPatterns(e,i,n)){var o;const r=`No config is applied to "${null!=(o=e.filename)?o:"(unknown)"}" because it matches one of \`ignore: ${JSON.stringify(i,ignoreListReplacer)}\` from "${n}"`;return debug(r),e.showConfig&&console.log(r),!0}if(r&&!matchesPatterns(e,r,n)){var t;const i=`No config is applied to "${null!=(t=e.filename)?t:"(unknown)"}" because it fails to match one of \`only: ${JSON.stringify(r,ignoreListReplacer)}\` from "${n}"`;return debug(i),e.showConfig&&console.log(i),!0}return!1}function matchesPatterns(e,i,r){return i.some((i=>matchPattern(i,r,e.filename,e)))}function matchPattern(e,i,r,n){if("function"==typeof e)return!!e(r,{dirname:i,envName:n.envName,caller:n.caller});if("string"!=typeof r)throw new Error("Configuration contains string/RegExp pattern, but no filename was passed to Babel");return"string"==typeof e&&(e=(0,_patternToRegex.default)(e,i)),e.test(r)}
//# sourceMappingURL=/sm/ed145a62fa0d0cdfce69bab4a3d74d7f069182443cbbda8cef37f7aa1ff7cda0.map