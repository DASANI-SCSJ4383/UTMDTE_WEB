/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/globby@13.1.1/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import fs from"node:fs";import nodePath from"node:path";import merge2 from"merge2";import fastGlob from"fast-glob";import dirGlob from"dir-glob";import{GITIGNORE_FILES_PATTERN,isIgnoredByIgnoreFiles,isIgnoredByIgnoreFilesSync}from"./ignore.js";import{FilterStream,toPath,isNegativePattern}from"./utilities.js";const assertPatternsInput=t=>{if(t.some((t=>"string"!=typeof t)))throw new TypeError("Patterns must be a string or an array of strings")},toPatternsArray=t=>(t=[...new Set([t].flat())],assertPatternsInput(t),t),checkCwdOption=t=>{if(!t.cwd)return;let e;try{e=fs.statSync(t.cwd)}catch{return}if(!e.isDirectory())throw new Error("The `cwd` option must be a path to a directory")},normalizeOptions=(t={})=>(t={ignore:[],expandDirectories:!0,...t,cwd:toPath(t.cwd)},checkCwdOption(t),t),normalizeArguments=t=>async(e,r)=>t(toPatternsArray(e),normalizeOptions(r)),normalizeArgumentsSync=t=>(e,r)=>t(toPatternsArray(e),normalizeOptions(r)),getIgnoreFilesPatterns=t=>{const{ignoreFiles:e,gitignore:r}=t,n=e?toPatternsArray(e):[];return r&&n.push(GITIGNORE_FILES_PATTERN),n},getFilter=async t=>{const e=getIgnoreFilesPatterns(t);return createFilterFunction(e.length>0&&await isIgnoredByIgnoreFiles(e,{cwd:t.cwd}))},getFilterSync=t=>{const e=getIgnoreFilesPatterns(t);return createFilterFunction(e.length>0&&isIgnoredByIgnoreFilesSync(e,{cwd:t.cwd}))},createFilterFunction=t=>{const e=new Set;return r=>{const n=r.path||r,o=nodePath.normalize(n),s=e.has(o)||t&&t(n);return e.add(o),!s}},unionFastGlobResults=(t,e)=>t.flat().filter((t=>e(t))),unionFastGlobStreams=(t,e)=>merge2(t).pipe(new FilterStream((t=>e(t)))),convertNegativePatterns=(t,e)=>{const r=[];for(;t.length>0;){const n=t.findIndex((t=>isNegativePattern(t)));if(-1===n){r.push({patterns:t,options:e});break}const o=t[n].slice(1);for(const t of r)t.options.ignore.push(o);0!==n&&r.push({patterns:t.slice(0,n),options:{...e,ignore:[...e.ignore,o]}}),t=t.slice(n+1)}return r},getDirGlobOptions=(t,e)=>({...e?{cwd:e}:{},...Array.isArray(t)?{files:t}:t}),generateTasks=async(t,e)=>{const r=convertNegativePatterns(t,e),{cwd:n,expandDirectories:o}=e;if(!o)return r;const s=getDirGlobOptions(o,n),i=n?{cwd:n}:void 0;return Promise.all(r.map((async t=>{let{patterns:e,options:r}=t;return[e,r.ignore]=await Promise.all([dirGlob(e,s),dirGlob(r.ignore,i)]),{patterns:e,options:r}})))},generateTasksSync=(t,e)=>{const r=convertNegativePatterns(t,e),{cwd:n,expandDirectories:o}=e;if(!o)return r;const s=getDirGlobOptions(o,n),i=n?{cwd:n}:void 0;return r.map((t=>{let{patterns:e,options:r}=t;return e=dirGlob.sync(e,s),r.ignore=dirGlob.sync(r.ignore,i),{patterns:e,options:r}}))};export const globby=normalizeArguments((async(t,e)=>{const[r,n]=await Promise.all([generateTasks(t,e),getFilter(e)]),o=await Promise.all(r.map((t=>fastGlob(t.patterns,t.options))));return unionFastGlobResults(o,n)}));export const globbySync=normalizeArgumentsSync(((t,e)=>{const r=generateTasksSync(t,e),n=getFilterSync(e),o=r.map((t=>fastGlob.sync(t.patterns,t.options)));return unionFastGlobResults(o,n)}));export const globbyStream=normalizeArgumentsSync(((t,e)=>{const r=generateTasksSync(t,e),n=getFilterSync(e),o=r.map((t=>fastGlob.stream(t.patterns,t.options)));return unionFastGlobStreams(o,n)}));export const isDynamicPattern=normalizeArgumentsSync(((t,e)=>t.some((t=>fastGlob.isDynamicPattern(t,e)))));export const generateGlobTasks=normalizeArguments(generateTasks);export const generateGlobTasksSync=normalizeArgumentsSync(generateTasksSync);export{isGitIgnored,isGitIgnoredSync}from"./ignore.js";
//# sourceMappingURL=/sm/7ae654ff5ab5025ffcb14d4479830ab476a6f087abe11b854993c53c604e72bd.map