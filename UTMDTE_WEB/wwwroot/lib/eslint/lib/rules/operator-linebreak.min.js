/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/eslint@8.11.0/lib/rules/operator-linebreak.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
"use strict";const astUtils=require("./utils/ast-utils");module.exports={meta:{type:"layout",docs:{description:"enforce consistent linebreak style for operators",recommended:!1,url:"https://eslint.org/docs/rules/operator-linebreak"},schema:[{enum:["after","before","none",null]},{type:"object",properties:{overrides:{type:"object",additionalProperties:{enum:["after","before","none","ignore"]}}},additionalProperties:!1}],fixable:"code",messages:{operatorAtBeginning:"'{{operator}}' should be placed at the beginning of the line.",operatorAtEnd:"'{{operator}}' should be placed at the end of the line.",badLinebreak:"Bad line breaking before and after '{{operator}}'.",noLinebreak:"There should be no line break before or after '{{operator}}'."}},create(e){const o=!e.options[0],t=e.options[0]||"after",n=e.options[1]||{},r=n.overrides?Object.assign({},n.overrides):{};o&&!r["?"]&&(r["?"]="before"),o&&!r[":"]&&(r[":"]="before");const a=e.getSourceCode();function i(o,n,i){const s=a.getTokenBefore(n,(e=>e.value===i)),l=a.getTokenBefore(s),c=a.getTokenAfter(s),d=r[i],p=d||t,f=function(e,o){return t=>{const n=a.getTokenBefore(e),r=a.getTokenAfter(e),i=a.text.slice(n.range[1],e.range[0]),s=a.text.slice(e.range[1],r.range[0]);let l,c;if(!astUtils.isTokenOnSameLine(n,e)!=!astUtils.isTokenOnSameLine(e,r)&&"none"!==o){if(a.getTokenBefore(e,{includeComments:!0})!==n&&a.getTokenAfter(e,{includeComments:!0})!==r)return null;l=s,c=i}else{const e=astUtils.createGlobalLinebreakMatcher();if(l="before"===o||i.trim()?i:i.replace(e,""),c="after"===o||s.trim()?s:s.replace(e,""),l===i&&c===s)return null}return""===c&&"Punctuator"===r.type&&"+-".includes(e.value)&&r.value===e.value&&(c+=" "),t.replaceTextRange([n.range[1],r.range[0]],l+e.value+c)}}(s,p);astUtils.isTokenOnSameLine(l,s)&&astUtils.isTokenOnSameLine(s,c)||("ignore"===d||astUtils.isTokenOnSameLine(l,s)||astUtils.isTokenOnSameLine(s,c)?"before"===p&&astUtils.isTokenOnSameLine(l,s)?e.report({node:o,loc:s.loc,messageId:"operatorAtBeginning",data:{operator:i},fix:f}):"after"===p&&astUtils.isTokenOnSameLine(s,c)?e.report({node:o,loc:s.loc,messageId:"operatorAtEnd",data:{operator:i},fix:f}):"none"===p&&e.report({node:o,loc:s.loc,messageId:"noLinebreak",data:{operator:i},fix:f}):e.report({node:o,loc:s.loc,messageId:"badLinebreak",data:{operator:i},fix:f}))}function s(e){i(e,e.right,e.operator)}return{BinaryExpression:s,LogicalExpression:s,AssignmentExpression:s,VariableDeclarator(e){e.init&&i(e,e.init,"=")},PropertyDefinition(e){e.value&&i(e,e.value,"=")},ConditionalExpression(e){i(e,e.consequent,"?"),i(e,e.alternate,":")}}}};
//# sourceMappingURL=/sm/838ff3af15cffd8468caf49ee34165e00a82f38118bb34ba59775d7c62859c55.map