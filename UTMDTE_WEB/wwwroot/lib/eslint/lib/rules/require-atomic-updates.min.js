/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/eslint@8.11.0/lib/rules/require-atomic-updates.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
"use strict";function createReferenceMap(e,t=new Map){for(const r of e.references)null!==r.resolved&&t.set(r.identifier,r);for(const r of e.childScopes)"function"!==r.type&&createReferenceMap(r,t);return t}function getWriteExpr(e){if(e.writeExpr)return e.writeExpr;let t=e.identifier;for(;t;){const e=t.parent.type;if("AssignmentExpression"===e&&t.parent.left===t)return t.parent.right;if("MemberExpression"!==e||t.parent.object!==t)break;t=t.parent}return null}function isLocalVariableWithoutEscape(e,t){if(!e)return!1;if(t&&e.defs.some((e=>"Parameter"===e.type)))return!1;const r=e.scope.variableScope;return e.references.every((e=>e.from.variableScope===r))}class SegmentInfo{constructor(){this.info=new WeakMap}initialize(e){const t=new Set,r=new Set;for(const a of e.prevSegments){const e=this.info.get(a);e&&(e.outdatedReadVariables.forEach(Set.prototype.add,t),e.freshReadVariables.forEach(Set.prototype.add,r))}this.info.set(e,{outdatedReadVariables:t,freshReadVariables:r})}markAsRead(e,t){for(const r of e){const e=this.info.get(r);e&&(e.freshReadVariables.add(t),e.outdatedReadVariables.delete(t))}}makeOutdated(e){for(const t of e){const e=this.info.get(t);e&&(e.freshReadVariables.forEach(Set.prototype.add,e.outdatedReadVariables),e.freshReadVariables.clear())}}isOutdated(e,t){for(const r of e){const e=this.info.get(r);if(e&&e.outdatedReadVariables.has(t))return!0}return!1}}module.exports={meta:{type:"problem",docs:{description:"disallow assignments that can lead to race conditions due to usage of `await` or `yield`",recommended:!1,url:"https://eslint.org/docs/rules/require-atomic-updates"},fixable:null,schema:[{type:"object",properties:{allowProperties:{type:"boolean",default:!1}},additionalProperties:!1}],messages:{nonAtomicUpdate:"Possible race condition: `{{value}}` might be reassigned based on an outdated value of `{{value}}`.",nonAtomicObjectUpdate:"Possible race condition: `{{value}}` might be assigned based on an outdated state of `{{object}}`."}},create(e){const t=!!e.options[0]&&e.options[0].allowProperties,r=e.getSourceCode(),a=new Map,o=new SegmentInfo;let n=null;return{onCodePathStart(t){const r=e.getScope(),a="function"===r.type&&(r.block.async||r.block.generator);n={upper:n,codePath:t,referenceMap:a?createReferenceMap(r):null}},onCodePathEnd(){n=n.upper},onCodePathSegmentStart(e){o.initialize(e)},Identifier(e){const{codePath:t,referenceMap:r}=n,s=r&&r.get(e);if(!s)return;const i=s.resolved,d=getWriteExpr(s),c="MemberExpression"===s.identifier.parent.type;if(!s.isRead()||d&&"="===d.parent.operator||o.markAsRead(t.currentSegments,i),d&&d.parent.right===d&&!isLocalVariableWithoutEscape(i,c)){let e=a.get(d);e||(e=[],a.set(d,e)),e.push(s)}},":expression:exit"(s){const{codePath:i,referenceMap:d}=n;if(!d)return;"AwaitExpression"!==s.type&&"YieldExpression"!==s.type||o.makeOutdated(i.currentSegments);const c=a.get(s);if(c){a.delete(s);for(const a of c){const n=a.resolved;o.isOutdated(i.currentSegments,n)&&(s.parent.left===a.identifier?e.report({node:s.parent,messageId:"nonAtomicUpdate",data:{value:n.name}}):t||e.report({node:s.parent,messageId:"nonAtomicObjectUpdate",data:{value:r.getText(s.parent.left),object:n.name}}))}}}}}};
//# sourceMappingURL=/sm/2e3e1aed5dd33207d7482d9deedd990b0fcd5335a8e4bd1ae35128db3ea0f083.map