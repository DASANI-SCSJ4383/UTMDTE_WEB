/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/eslint@8.11.0/lib/rule-tester/rule-tester.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
"use strict";const assert=require("assert"),path=require("path"),util=require("util"),merge=require("lodash.merge"),equal=require("fast-deep-equal"),Traverser=require("../../lib/shared/traverser"),{getRuleOptionsSchema:getRuleOptionsSchema,validate:validate}=require("../shared/config-validator"),{Linter:Linter,SourceCodeFixer:SourceCodeFixer,interpolate:interpolate}=require("../linter"),ajv=require("../shared/ajv")({strictDefaults:!0}),espreePath=require.resolve("espree"),parserSymbol=Symbol.for("eslint.RuleTester.parser"),{SourceCode:SourceCode}=require("../source-code"),testerDefaultConfig={rules:{}};let defaultConfig={rules:{}};const RuleTesterParameters=["name","code","filename","options","errors","output","only"],errorObjectParameters=new Set(["message","messageId","data","type","line","column","endLine","endColumn","suggestions"]),friendlyErrorObjectParameterList=`[${[...errorObjectParameters].map((e=>`'${e}'`)).join(", ")}]`,suggestionObjectParameters=new Set(["desc","messageId","data","output"]),friendlySuggestionObjectParameterList=`[${[...suggestionObjectParameters].map((e=>`'${e}'`)).join(", ")}]`,hasOwnProperty=Function.call.bind(Object.hasOwnProperty);function cloneDeeplyExcludesParent(e){if("object"==typeof e&&null!==e){if(Array.isArray(e))return e.map(cloneDeeplyExcludesParent);const t={};for(const s in e)"parent"!==s&&hasOwnProperty(e,s)&&(t[s]=cloneDeeplyExcludesParent(e[s]));return t}return e}function freezeDeeply(e){if("object"==typeof e&&null!==e){if(Array.isArray(e))e.forEach(freezeDeeply);else for(const t in e)"parent"!==t&&hasOwnProperty(e,t)&&freezeDeeply(e[t]);Object.freeze(e)}}function sanitize(e){return"string"!=typeof e?"":e.replace(/[\u0000-\u0009\u000b-\u001a]/gu,(e=>`\\u${e.codePointAt(0).toString(16).padStart(4,"0")}`))}function defineStartEndAsError(e,t){Object.defineProperties(t,{start:{get(){throw new Error(`Use ${e}.range[0] instead of ${e}.start`)},configurable:!0,enumerable:!1},end:{get(){throw new Error(`Use ${e}.range[1] instead of ${e}.end`)},configurable:!0,enumerable:!1}})}function defineStartEndAsErrorInTree(e,t){Traverser.traverse(e,{visitorKeys:t,enter:defineStartEndAsError.bind(null,"node")}),e.tokens.forEach(defineStartEndAsError.bind(null,"token")),e.comments.forEach(defineStartEndAsError.bind(null,"token"))}function wrapParser(e){return"function"==typeof e.parseForESLint?{[parserSymbol]:e,parseForESLint(...t){const s=e.parseForESLint(...t);return defineStartEndAsErrorInTree(s.ast,s.visitorKeys),s}}:{[parserSymbol]:e,parse(...t){const s=e.parse(...t);return defineStartEndAsErrorInTree(s),s}}}function getCommentsDeprecation(){throw new Error("`SourceCode#getComments()` is deprecated and will be removed in a future major version. Use `getCommentsBefore()`, `getCommentsAfter()`, and `getCommentsInside()` instead.")}const DESCRIBE=Symbol("describe"),IT=Symbol("it"),IT_ONLY=Symbol("itOnly");function itDefaultHandler(e,t){try{return t.call(this)}catch(e){throw e instanceof assert.AssertionError&&(e.message+=` (${util.inspect(e.actual)} ${e.operator} ${util.inspect(e.expected)})`),e}}function describeDefaultHandler(e,t){return t.call(this)}class RuleTester{constructor(e){this.testerConfig=merge({},defaultConfig,e,{rules:{"rule-tester/validate-ast":"error"}}),this.rules={},this.linter=new Linter}static setDefaultConfig(e){if("object"!=typeof e)throw new TypeError("RuleTester.setDefaultConfig: config must be an object");defaultConfig=e,defaultConfig.rules=defaultConfig.rules||{}}static getDefaultConfig(){return defaultConfig}static resetDefaultConfig(){defaultConfig=merge({},testerDefaultConfig)}static get describe(){return this[DESCRIBE]||("function"==typeof describe?describe:describeDefaultHandler)}static set describe(e){this[DESCRIBE]=e}static get it(){return this[IT]||("function"==typeof it?it:itDefaultHandler)}static set it(e){this[IT]=e}static only(e){return"string"==typeof e?{code:e,only:!0}:{...e,only:!0}}static get itOnly(){if("function"==typeof this[IT_ONLY])return this[IT_ONLY];if("function"==typeof this[IT]&&"function"==typeof this[IT].only)return Function.bind.call(this[IT].only,this[IT]);if("function"==typeof it&&"function"==typeof it.only)return Function.bind.call(it.only,it);if("function"==typeof this[DESCRIBE]||"function"==typeof this[IT])throw new Error("Set `RuleTester.itOnly` to use `only` with a custom test framework.\nSee https://eslint.org/docs/developer-guide/nodejs-api#customizing-ruletester for more.");if("function"==typeof it)throw new Error("The current test framework does not support exclusive tests with `only`.");throw new Error("To use `only`, use RuleTester with a test framework that provides `it.only()` like Mocha.")}static set itOnly(e){this[IT_ONLY]=e}defineRule(e,t){this.rules[e]=t}run(e,t,s){const r=this.testerConfig,o=[],a=this.linter;if(!s||"object"!=typeof s)throw new TypeError(`Test Scenarios for rule ${e} : Could not find test scenario object`);if(["valid","invalid"].forEach((e=>{s[e]||o.push(`Could not find any ${e} test scenarios`)})),o.length>0)throw new Error([`Test Scenarios for rule ${e} is invalid:`].concat(o).join("\n"));function n(s){let o,n,i,u,l,c=merge({},r);if("string"==typeof s)o=s;else{o=s.code;const e={...s};for(const t of RuleTesterParameters)delete e[t];c=merge(c,e)}s.filename&&(n=s.filename),hasOwnProperty(s,"options")?(assert(Array.isArray(s.options),"options must be an array"),c.rules[e]=[1].concat(s.options)):c.rules[e]=1;const d=getRuleOptionsSchema(t);if(a.defineRule("rule-tester/validate-ast",(()=>({Program(e){u=cloneDeeplyExcludesParent(e)},"Program:exit"(e){l=e}}))),"string"==typeof c.parser?assert(path.isAbsolute(c.parser),"Parsers provided as strings to RuleTester must be absolute paths"):c.parser=espreePath,a.defineParser(c.parser,wrapParser(require(c.parser))),d){if(ajv.validateSchema(d),ajv.errors){const t=ajv.errors.map((e=>`\t${"."===e.dataPath[0]?e.dataPath.slice(1):e.dataPath}: ${e.message}`)).join("\n");throw new Error([`Schema for rule ${e} is invalid:`,t])}try{ajv.compile(d)}catch(t){throw new Error(`Schema for rule ${e} is invalid: ${t.message}`)}}validate(c,"rule-tester",(s=>s===e?t:null));const{getComments:f}=SourceCode.prototype;let g;try{SourceCode.prototype.getComments=getCommentsDeprecation,g=a.verify(o,c,n)}finally{SourceCode.prototype.getComments=f}const p=g.find((e=>e.fatal));if(assert(!p,`A fatal parsing error occurred: ${p&&p.message}`),g.some((e=>e.fix))){i=SourceCodeFixer.applyFixes(o,g).output;const e=a.verify(i,c,n).find((e=>e.fatal));assert(!e,["A fatal parsing error occurred in autofix.",`Error: ${e&&e.message}`,"Autofix output:",i].join("\n"))}else i=o;return{messages:g,output:i,beforeAST:u,afterAST:cloneDeeplyExcludesParent(l)}}function i(e,t){equal(e,t)||assert.fail("Rule should not modify AST.")}function u(e,t){t instanceof RegExp?assert.ok(t.test(e),`Expected '${e}' to match ${t}`):assert.strictEqual(e,t)}a.defineRule(e,Object.assign({},t,{create:e=>(freezeDeeply(e.options),freezeDeeply(e.settings),freezeDeeply(e.parserOptions),("function"==typeof t?t:t.create)(e))})),a.defineRules(this.rules),this.constructor.describe(e,(()=>{this.constructor.describe("valid",(()=>{s.valid.forEach((e=>{this.constructor[e.only?"itOnly":"it"](sanitize("object"==typeof e?e.name||e.code:e),(()=>{!function(e){const t="object"==typeof e?e.code:e;assert.ok("string"==typeof t,"Test case must specify a string value for 'code'"),e.name&&assert.ok("string"==typeof e.name,"Optional test case property 'name' must be a string");const s=n(e),r=s.messages;assert.strictEqual(r.length,0,util.format("Should have no errors but had %d: %s",r.length,util.inspect(r))),i(s.beforeAST,s.afterAST)}(e)}))}))})),this.constructor.describe("invalid",(()=>{s.invalid.forEach((s=>{this.constructor[s.only?"itOnly":"it"](sanitize(s.name||s.code),(()=>{!function(s){assert.ok("string"==typeof s.code,"Test case must specify a string value for 'code'"),s.name&&assert.ok("string"==typeof s.name,"Optional test case property 'name' must be a string"),assert.ok(s.errors||0===s.errors,`Did not specify errors for an invalid test of ${e}`),Array.isArray(s.errors)&&0===s.errors.length&&assert.fail("Invalid cases must have at least one error");const r=hasOwnProperty(t,"meta")&&hasOwnProperty(t.meta,"messages"),o=r?`[${Object.keys(t.meta.messages).map((e=>`'${e}'`)).join(", ")}]`:null,a=n(s),l=a.messages;if("number"==typeof s.errors)0===s.errors&&assert.fail("Invalid cases must have 'error' value greater than 0"),assert.strictEqual(l.length,s.errors,util.format("Should have %d error%s but had %d: %s",s.errors,1===s.errors?"":"s",l.length,util.inspect(l)));else{assert.strictEqual(l.length,s.errors.length,util.format("Should have %d error%s but had %d: %s",s.errors.length,1===s.errors.length?"":"s",l.length,util.inspect(l)));const a=l.some((t=>t.ruleId===e));for(let e=0,n=s.errors.length;e<n;e++){const n=s.errors[e],i=l[e];if(assert(a,"Error rule name should be the same as the name of the rule being tested"),"string"==typeof n||n instanceof RegExp)u(i.message,n);else if("object"==typeof n&&null!==n){if(Object.keys(n).forEach((e=>{assert.ok(errorObjectParameters.has(e),`Invalid error property name '${e}'. Expected one of ${friendlyErrorObjectParameterList}.`)})),hasOwnProperty(n,"message"))assert.ok(!hasOwnProperty(n,"messageId"),"Error should not specify both 'message' and a 'messageId'."),assert.ok(!hasOwnProperty(n,"data"),"Error should not specify both 'data' and 'message'."),u(i.message,n.message);else if(hasOwnProperty(n,"messageId")&&(assert.ok(r,"Error can not use 'messageId' if rule under test doesn't define 'meta.messages'."),hasOwnProperty(t.meta.messages,n.messageId)||assert(!1,`Invalid messageId '${n.messageId}'. Expected one of ${o}.`),assert.strictEqual(i.messageId,n.messageId,`messageId '${i.messageId}' does not match expected messageId '${n.messageId}'.`),hasOwnProperty(n,"data"))){const e=t.meta.messages[n.messageId],s=interpolate(e,n.data);assert.strictEqual(i.message,s,`Hydrated message "${s}" does not match "${i.message}"`)}assert.ok(!hasOwnProperty(n,"data")||hasOwnProperty(n,"messageId"),"Error must specify 'messageId' if 'data' is used."),n.type&&assert.strictEqual(i.nodeType,n.type,`Error type should be ${n.type}, found ${i.nodeType}`),hasOwnProperty(n,"line")&&assert.strictEqual(i.line,n.line,`Error line should be ${n.line}`),hasOwnProperty(n,"column")&&assert.strictEqual(i.column,n.column,`Error column should be ${n.column}`),hasOwnProperty(n,"endLine")&&assert.strictEqual(i.endLine,n.endLine,`Error endLine should be ${n.endLine}`),hasOwnProperty(n,"endColumn")&&assert.strictEqual(i.endColumn,n.endColumn,`Error endColumn should be ${n.endColumn}`),hasOwnProperty(n,"suggestions")&&(!n.suggestions||Array.isArray(n.suggestions)&&0===n.suggestions.length?Array.isArray(i.suggestions)&&i.suggestions.length>0&&assert.fail(`Error should have no suggestions on error with message: "${i.message}"`):(assert.strictEqual(Array.isArray(i.suggestions),!0,`Error should have an array of suggestions. Instead received "${i.suggestions}" on error with message: "${i.message}"`),assert.strictEqual(i.suggestions.length,n.suggestions.length,`Error should have ${n.suggestions.length} suggestions. Instead found ${i.suggestions.length} suggestions`),n.suggestions.forEach(((e,a)=>{assert.ok("object"==typeof e&&null!==e,"Test suggestion in 'suggestions' array must be an object."),Object.keys(e).forEach((e=>{assert.ok(suggestionObjectParameters.has(e),`Invalid suggestion property name '${e}'. Expected one of ${friendlySuggestionObjectParameterList}.`)}));const n=i.suggestions[a],u=`Error Suggestion at index ${a} :`;if(hasOwnProperty(e,"desc")&&(assert.ok(!hasOwnProperty(e,"data"),`${u} Test should not specify both 'desc' and 'data'.`),assert.strictEqual(n.desc,e.desc,`${u} desc should be "${e.desc}" but got "${n.desc}" instead.`)),hasOwnProperty(e,"messageId")){if(assert.ok(r,`${u} Test can not use 'messageId' if rule under test doesn't define 'meta.messages'.`),assert.ok(hasOwnProperty(t.meta.messages,e.messageId),`${u} Test has invalid messageId '${e.messageId}', the rule under test allows only one of ${o}.`),assert.strictEqual(n.messageId,e.messageId,`${u} messageId should be '${e.messageId}' but got '${n.messageId}' instead.`),hasOwnProperty(e,"data")){const s=t.meta.messages[e.messageId],r=interpolate(s,e.data);assert.strictEqual(n.desc,r,`${u} Hydrated test desc "${r}" does not match received desc "${n.desc}".`)}}else assert.ok(!hasOwnProperty(e,"data"),`${u} Test must specify 'messageId' if 'data' is used.`);if(hasOwnProperty(e,"output")){const t=SourceCodeFixer.applyFixes(s.code,[n]).output;assert.strictEqual(t,e.output,`Expected the applied suggestion fix to match the test suggestion output for suggestion at index: ${a} on error with message: "${i.message}"`)}}))))}else assert.fail(`Error should be a string, object, or RegExp, but found (${util.inspect(i)})`)}}hasOwnProperty(s,"output")?null===s.output?assert.strictEqual(a.output,s.code,"Expected no autofixes to be suggested"):assert.strictEqual(a.output,s.output,"Output is incorrect."):assert.strictEqual(a.output,s.code,"The rule fixed the code. Please add 'output' property."),i(a.beforeAST,a.afterAST)}(s)}))}))}))}))}}RuleTester[DESCRIBE]=RuleTester[IT]=RuleTester[IT_ONLY]=null,module.exports=RuleTester;
//# sourceMappingURL=/sm/3c30a63130630c9464c3227384056ee870024a749eba30abaea8c26a7af8dff3.map