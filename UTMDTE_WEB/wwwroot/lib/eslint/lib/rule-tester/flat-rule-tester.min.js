/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/eslint@8.11.0/lib/rule-tester/flat-rule-tester.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
"use strict";const assert=require("assert"),util=require("util"),equal=require("fast-deep-equal"),Traverser=require("../shared/traverser"),{getRuleOptionsSchema:getRuleOptionsSchema}=require("../config/flat-config-helpers"),{Linter:Linter,SourceCodeFixer:SourceCodeFixer,interpolate:interpolate}=require("../linter"),{FlatConfigArray:FlatConfigArray}=require("../config/flat-config-array"),{defaultConfig:defaultConfig}=require("../config/default-config"),ajv=require("../shared/ajv")({strictDefaults:!0}),parserSymbol=Symbol.for("eslint.RuleTester.parser"),{SourceCode:SourceCode}=require("../source-code"),{ConfigArraySymbol:ConfigArraySymbol}=require("@humanwhocodes/config-array"),testerDefaultConfig={rules:{}};let sharedDefaultConfig={rules:{}};const RuleTesterParameters=["name","code","filename","options","errors","output","only"],errorObjectParameters=new Set(["message","messageId","data","type","line","column","endLine","endColumn","suggestions"]),friendlyErrorObjectParameterList=`[${[...errorObjectParameters].map((e=>`'${e}'`)).join(", ")}]`,suggestionObjectParameters=new Set(["desc","messageId","data","output"]),friendlySuggestionObjectParameterList=`[${[...suggestionObjectParameters].map((e=>`'${e}'`)).join(", ")}]`,hasOwnProperty=Function.call.bind(Object.hasOwnProperty);function cloneDeeplyExcludesParent(e){if("object"==typeof e&&null!==e){if(Array.isArray(e))return e.map(cloneDeeplyExcludesParent);const t={};for(const s in e)"parent"!==s&&hasOwnProperty(e,s)&&(t[s]=cloneDeeplyExcludesParent(e[s]));return t}return e}function freezeDeeply(e){if("object"==typeof e&&null!==e){if(Array.isArray(e))e.forEach(freezeDeeply);else for(const t in e)"parent"!==t&&hasOwnProperty(e,t)&&freezeDeeply(e[t]);Object.freeze(e)}}function sanitize(e){return"string"!=typeof e?"":e.replace(/[\u0000-\u0009\u000b-\u001a]/gu,(e=>`\\u${e.codePointAt(0).toString(16).padStart(4,"0")}`))}function defineStartEndAsError(e,t){Object.defineProperties(t,{start:{get(){throw new Error(`Use ${e}.range[0] instead of ${e}.start`)},configurable:!0,enumerable:!1},end:{get(){throw new Error(`Use ${e}.range[1] instead of ${e}.end`)},configurable:!0,enumerable:!1}})}function defineStartEndAsErrorInTree(e,t){Traverser.traverse(e,{visitorKeys:t,enter:defineStartEndAsError.bind(null,"node")}),e.tokens.forEach(defineStartEndAsError.bind(null,"token")),e.comments.forEach(defineStartEndAsError.bind(null,"token"))}function wrapParser(e){return"function"==typeof e.parseForESLint?{[parserSymbol]:e,parseForESLint(...t){const s=e.parseForESLint(...t);return defineStartEndAsErrorInTree(s.ast,s.visitorKeys),s}}:{[parserSymbol]:e,parse(...t){const s=e.parse(...t);return defineStartEndAsErrorInTree(s),s}}}function getCommentsDeprecation(){throw new Error("`SourceCode#getComments()` is deprecated and will be removed in a future major version. Use `getCommentsBefore()`, `getCommentsAfter()`, and `getCommentsInside()` instead.")}const DESCRIBE=Symbol("describe"),IT=Symbol("it"),IT_ONLY=Symbol("itOnly");function itDefaultHandler(e,t){try{return t.call(this)}catch(e){throw e instanceof assert.AssertionError&&(e.message+=` (${util.inspect(e.actual)} ${e.operator} ${util.inspect(e.expected)})`),e}}function describeDefaultHandler(e,t){return t.call(this)}class FlatRuleTester{constructor(e={}){this.testerConfig=[sharedDefaultConfig,e,{rules:{"rule-tester/validate-ast":"error"}}],this.linter=new Linter({configType:"flat"})}static setDefaultConfig(e){if("object"!=typeof e)throw new TypeError("FlatRuleTester.setDefaultConfig: config must be an object");sharedDefaultConfig=e,sharedDefaultConfig.rules=sharedDefaultConfig.rules||{}}static getDefaultConfig(){return sharedDefaultConfig}static resetDefaultConfig(){sharedDefaultConfig={rules:{...testerDefaultConfig.rules}}}static get describe(){return this[DESCRIBE]||("function"==typeof describe?describe:describeDefaultHandler)}static set describe(e){this[DESCRIBE]=e}static get it(){return this[IT]||("function"==typeof it?it:itDefaultHandler)}static set it(e){this[IT]=e}static only(e){return"string"==typeof e?{code:e,only:!0}:{...e,only:!0}}static get itOnly(){if("function"==typeof this[IT_ONLY])return this[IT_ONLY];if("function"==typeof this[IT]&&"function"==typeof this[IT].only)return Function.bind.call(this[IT].only,this[IT]);if("function"==typeof it&&"function"==typeof it.only)return Function.bind.call(it.only,it);if("function"==typeof this[DESCRIBE]||"function"==typeof this[IT])throw new Error("Set `RuleTester.itOnly` to use `only` with a custom test framework.\nSee https://eslint.org/docs/developer-guide/nodejs-api#customizing-ruletester for more.");if("function"==typeof it)throw new Error("The current test framework does not support exclusive tests with `only`.");throw new Error("To use `only`, use RuleTester with a test framework that provides `it.only()` like Mocha.")}static set itOnly(e){this[IT_ONLY]=e}run(e,t,s){const r=this.testerConfig,o=[],a=this.linter,n=`rule-to-test/${e}`;if(!s||"object"!=typeof s)throw new TypeError(`Test Scenarios for rule ${e} : Could not find test scenario object`);if(["valid","invalid"].forEach((e=>{s[e]||o.push(`Could not find any ${e} test scenarios`)})),o.length>0)throw new Error([`Test Scenarios for rule ${e} is invalid:`].concat(o).join("\n"));const i={plugins:{"@":{parsers:{...defaultConfig[0].plugins["@"].parsers},rules:defaultConfig[0].plugins["@"].rules},"rule-to-test":{rules:{[e]:Object.assign({},t,{create:e=>(freezeDeeply(e.options),freezeDeeply(e.settings),freezeDeeply(e.parserOptions),("function"==typeof t?t:t.create)(e))})}}},languageOptions:{...defaultConfig[0].languageOptions}};function u(s){const o=new FlatConfigArray(r,{baseConfig:i});let u,l,c,d,f;if(o[ConfigArraySymbol.finalizeConfig]=function(...e){const t=Object.getPrototypeOf(this)[ConfigArraySymbol.finalizeConfig].apply(this,e);return t.languageOptions.parser=wrapParser(t.languageOptions.parser),t},"string"==typeof s)u=s;else{u=s.code;const e={...s};for(const t of RuleTesterParameters)delete e[t];if(e.languageOptions&&e.languageOptions.parser){const t=e.languageOptions.parser;if(t&&"object"!=typeof t)throw new Error("Parser must be an object with a parse() or parseForESLint() method.")}o.push(e)}s.filename&&(l=s.filename);let g=1;hasOwnProperty(s,"options")&&(assert(Array.isArray(s.options),"options must be an array"),g=[1,...s.options]),o.push({rules:{[n]:g}});const p=getRuleOptionsSchema(t);if(o.push({plugins:{"rule-tester":{rules:{"validate-ast":()=>({Program(e){d=cloneDeeplyExcludesParent(e)},"Program:exit"(e){f=e}})}}}}),p){if(ajv.validateSchema(p),ajv.errors){const t=ajv.errors.map((e=>`\t${"."===e.dataPath[0]?e.dataPath.slice(1):e.dataPath}: ${e.message}`)).join("\n");throw new Error([`Schema for rule ${e} is invalid:`,t])}try{ajv.compile(p)}catch(t){throw new Error(`Schema for rule ${e} is invalid: ${t.message}`)}}const{getComments:m}=SourceCode.prototype;let h;try{o.normalizeSync(),o.getConfig("test.js")}catch(e){throw e.message=`ESLint configuration in rule-tester is invalid: ${e.message}`,e}try{SourceCode.prototype.getComments=getCommentsDeprecation,h=a.verify(u,o,l)}finally{SourceCode.prototype.getComments=m}const y=h.find((e=>e.fatal));if(assert(!y,`A fatal parsing error occurred: ${y&&y.message}`),h.some((e=>e.fix))){c=SourceCodeFixer.applyFixes(u,h).output;const e=a.verify(c,o,l).find((e=>e.fatal));assert(!e,["A fatal parsing error occurred in autofix.",`Error: ${e&&e.message}`,"Autofix output:",c].join("\n"))}else c=u;return{messages:h,output:c,beforeAST:d,afterAST:cloneDeeplyExcludesParent(f)}}function l(e,t){equal(e,t)||assert.fail("Rule should not modify AST.")}function c(e,t){t instanceof RegExp?assert.ok(t.test(e),`Expected '${e}' to match ${t}`):assert.strictEqual(e,t)}this.constructor.describe(e,(()=>{this.constructor.describe("valid",(()=>{s.valid.forEach((e=>{this.constructor[e.only?"itOnly":"it"](sanitize("object"==typeof e?e.name||e.code:e),(()=>{!function(e){const t="object"==typeof e?e.code:e;assert.ok("string"==typeof t,"Test case must specify a string value for 'code'"),e.name&&assert.ok("string"==typeof e.name,"Optional test case property 'name' must be a string");const s=u(e),r=s.messages;assert.strictEqual(r.length,0,util.format("Should have no errors but had %d: %s",r.length,util.inspect(r))),l(s.beforeAST,s.afterAST)}(e)}))}))})),this.constructor.describe("invalid",(()=>{s.invalid.forEach((s=>{this.constructor[s.only?"itOnly":"it"](sanitize(s.name||s.code),(()=>{!function(s){assert.ok("string"==typeof s.code,"Test case must specify a string value for 'code'"),s.name&&assert.ok("string"==typeof s.name,"Optional test case property 'name' must be a string"),assert.ok(s.errors||0===s.errors,`Did not specify errors for an invalid test of ${e}`),Array.isArray(s.errors)&&0===s.errors.length&&assert.fail("Invalid cases must have at least one error");const r=hasOwnProperty(t,"meta")&&hasOwnProperty(t.meta,"messages"),o=r?`[${Object.keys(t.meta.messages).map((e=>`'${e}'`)).join(", ")}]`:null,a=u(s),i=a.messages;if("number"==typeof s.errors)0===s.errors&&assert.fail("Invalid cases must have 'error' value greater than 0"),assert.strictEqual(i.length,s.errors,util.format("Should have %d error%s but had %d: %s",s.errors,1===s.errors?"":"s",i.length,util.inspect(i)));else{assert.strictEqual(i.length,s.errors.length,util.format("Should have %d error%s but had %d: %s",s.errors.length,1===s.errors.length?"":"s",i.length,util.inspect(i)));const e=i.some((e=>e.ruleId===n));for(let a=0,n=s.errors.length;a<n;a++){const n=s.errors[a],u=i[a];if(assert(e,"Error rule name should be the same as the name of the rule being tested"),"string"==typeof n||n instanceof RegExp)c(u.message,n);else if("object"==typeof n&&null!==n){if(Object.keys(n).forEach((e=>{assert.ok(errorObjectParameters.has(e),`Invalid error property name '${e}'. Expected one of ${friendlyErrorObjectParameterList}.`)})),hasOwnProperty(n,"message"))assert.ok(!hasOwnProperty(n,"messageId"),"Error should not specify both 'message' and a 'messageId'."),assert.ok(!hasOwnProperty(n,"data"),"Error should not specify both 'data' and 'message'."),c(u.message,n.message);else if(hasOwnProperty(n,"messageId")&&(assert.ok(r,"Error can not use 'messageId' if rule under test doesn't define 'meta.messages'."),hasOwnProperty(t.meta.messages,n.messageId)||assert(!1,`Invalid messageId '${n.messageId}'. Expected one of ${o}.`),assert.strictEqual(u.messageId,n.messageId,`messageId '${u.messageId}' does not match expected messageId '${n.messageId}'.`),hasOwnProperty(n,"data"))){const e=t.meta.messages[n.messageId],s=interpolate(e,n.data);assert.strictEqual(u.message,s,`Hydrated message "${s}" does not match "${u.message}"`)}assert.ok(!hasOwnProperty(n,"data")||hasOwnProperty(n,"messageId"),"Error must specify 'messageId' if 'data' is used."),n.type&&assert.strictEqual(u.nodeType,n.type,`Error type should be ${n.type}, found ${u.nodeType}`),hasOwnProperty(n,"line")&&assert.strictEqual(u.line,n.line,`Error line should be ${n.line}`),hasOwnProperty(n,"column")&&assert.strictEqual(u.column,n.column,`Error column should be ${n.column}`),hasOwnProperty(n,"endLine")&&assert.strictEqual(u.endLine,n.endLine,`Error endLine should be ${n.endLine}`),hasOwnProperty(n,"endColumn")&&assert.strictEqual(u.endColumn,n.endColumn,`Error endColumn should be ${n.endColumn}`),hasOwnProperty(n,"suggestions")&&(!n.suggestions||Array.isArray(n.suggestions)&&0===n.suggestions.length?Array.isArray(u.suggestions)&&u.suggestions.length>0&&assert.fail(`Error should have no suggestions on error with message: "${u.message}"`):(assert.strictEqual(Array.isArray(u.suggestions),!0,`Error should have an array of suggestions. Instead received "${u.suggestions}" on error with message: "${u.message}"`),assert.strictEqual(u.suggestions.length,n.suggestions.length,`Error should have ${n.suggestions.length} suggestions. Instead found ${u.suggestions.length} suggestions`),n.suggestions.forEach(((e,a)=>{assert.ok("object"==typeof e&&null!==e,"Test suggestion in 'suggestions' array must be an object."),Object.keys(e).forEach((e=>{assert.ok(suggestionObjectParameters.has(e),`Invalid suggestion property name '${e}'. Expected one of ${friendlySuggestionObjectParameterList}.`)}));const n=u.suggestions[a],i=`Error Suggestion at index ${a} :`;if(hasOwnProperty(e,"desc")&&(assert.ok(!hasOwnProperty(e,"data"),`${i} Test should not specify both 'desc' and 'data'.`),assert.strictEqual(n.desc,e.desc,`${i} desc should be "${e.desc}" but got "${n.desc}" instead.`)),hasOwnProperty(e,"messageId")){if(assert.ok(r,`${i} Test can not use 'messageId' if rule under test doesn't define 'meta.messages'.`),assert.ok(hasOwnProperty(t.meta.messages,e.messageId),`${i} Test has invalid messageId '${e.messageId}', the rule under test allows only one of ${o}.`),assert.strictEqual(n.messageId,e.messageId,`${i} messageId should be '${e.messageId}' but got '${n.messageId}' instead.`),hasOwnProperty(e,"data")){const s=t.meta.messages[e.messageId],r=interpolate(s,e.data);assert.strictEqual(n.desc,r,`${i} Hydrated test desc "${r}" does not match received desc "${n.desc}".`)}}else assert.ok(!hasOwnProperty(e,"data"),`${i} Test must specify 'messageId' if 'data' is used.`);if(hasOwnProperty(e,"output")){const t=SourceCodeFixer.applyFixes(s.code,[n]).output;assert.strictEqual(t,e.output,`Expected the applied suggestion fix to match the test suggestion output for suggestion at index: ${a} on error with message: "${u.message}"`)}}))))}else assert.fail(`Error should be a string, object, or RegExp, but found (${util.inspect(u)})`)}}hasOwnProperty(s,"output")?null===s.output?assert.strictEqual(a.output,s.code,"Expected no autofixes to be suggested"):assert.strictEqual(a.output,s.output,"Output is incorrect."):assert.strictEqual(a.output,s.code,"The rule fixed the code. Please add 'output' property."),l(a.beforeAST,a.afterAST)}(s)}))}))}))}))}}FlatRuleTester[DESCRIBE]=FlatRuleTester[IT]=FlatRuleTester[IT_ONLY]=null,module.exports=FlatRuleTester;
//# sourceMappingURL=/sm/0a0ce234c18483149e5d61c31e5fa57119753bcaa7c535e41520877c2a5a7dcc.map