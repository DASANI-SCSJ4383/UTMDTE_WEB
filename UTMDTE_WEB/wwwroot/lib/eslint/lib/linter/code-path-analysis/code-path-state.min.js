/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/eslint@8.11.0/lib/linter/code-path-analysis/code-path-state.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
"use strict";const CodePathSegment=require("./code-path-segment"),ForkContext=require("./fork-context");function addToReturnedOrThrown(t,e,o,n){for(let r=0;r<n.length;++r){const s=n[r];t.push(s),-1===e.indexOf(s)&&o.push(s)}}function getContinueContext(t,e){if(!e)return t.loopContext;let o=t.loopContext;for(;o;){if(o.label===e)return o;o=o.upper}return null}function getBreakContext(t,e){let o=t.breakContext;for(;o;){if(e?o.label===e:o.breakable)return o;o=o.upper}return null}function getReturnContext(t){let e=t.tryContext;for(;e;){if(e.hasFinalizer&&"finally"!==e.position)return e;e=e.upper}return t}function getThrowContext(t){let e=t.tryContext;for(;e;){if("try"===e.position||e.hasFinalizer&&"catch"===e.position)return e;e=e.upper}return t}function remove(t,e){t.splice(t.indexOf(e),1)}function removeConnection(t,e){for(let o=0;o<t.length;++o){const n=t[o],r=e[o];remove(n.nextSegments,r),remove(n.allNextSegments,r),remove(r.prevSegments,n),remove(r.allPrevSegments,n)}}function makeLooped(t,e,o){const n=CodePathSegment.flattenUnusedSegments(e),r=CodePathSegment.flattenUnusedSegments(o),s=Math.min(n.length,r.length);for(let e=0;e<s;++e){const o=n[e],s=r[e];s.reachable&&o.nextSegments.push(s),o.reachable&&s.prevSegments.push(o),o.allNextSegments.push(s),s.allPrevSegments.push(o),s.allPrevSegments.length>=2&&CodePathSegment.markPrevSegmentAsLooped(s,o),t.notifyLooped(o,s)}}function finalizeTestSegmentsOfFor(t,e,o){e.processed||(e.trueForkContext.add(o),e.falseForkContext.add(o),e.qqForkContext.add(o)),!0!==t.test&&t.brokenForkContext.addAll(e.falseForkContext),t.endOfTestSegments=e.trueForkContext.makeNext(0,-1)}class CodePathState{constructor(t,e){this.idGenerator=t,this.notifyLooped=e,this.forkContext=ForkContext.newRoot(t),this.choiceContext=null,this.switchContext=null,this.tryContext=null,this.loopContext=null,this.breakContext=null,this.chainContext=null,this.currentSegments=[],this.initialSegment=this.forkContext.head[0];const o=this.finalSegments=[],n=this.returnedForkContext=[],r=this.thrownForkContext=[];n.add=addToReturnedOrThrown.bind(null,n,r,o),r.add=addToReturnedOrThrown.bind(null,r,n,o)}get headSegments(){return this.forkContext.head}get parentForkContext(){const t=this.forkContext;return t&&t.upper}pushForkContext(t){return this.forkContext=ForkContext.newEmpty(this.forkContext,t),this.forkContext}popForkContext(){const t=this.forkContext;return this.forkContext=t.upper,this.forkContext.replaceHead(t.makeNext(0,-1)),t}forkPath(){this.forkContext.add(this.parentForkContext.makeNext(-1,-1))}forkBypassPath(){this.forkContext.add(this.parentForkContext.head)}pushChoiceContext(t,e){this.choiceContext={upper:this.choiceContext,kind:t,isForkingAsResult:e,trueForkContext:ForkContext.newEmpty(this.forkContext),falseForkContext:ForkContext.newEmpty(this.forkContext),qqForkContext:ForkContext.newEmpty(this.forkContext),processed:!1}}popChoiceContext(){const t=this.choiceContext;this.choiceContext=t.upper;const e=this.forkContext,o=e.head;switch(t.kind){case"&&":case"||":case"??":if(t.processed||(t.trueForkContext.add(o),t.falseForkContext.add(o),t.qqForkContext.add(o)),t.isForkingAsResult){const e=this.choiceContext;return e.trueForkContext.addAll(t.trueForkContext),e.falseForkContext.addAll(t.falseForkContext),e.qqForkContext.addAll(t.qqForkContext),e.processed=!0,t}break;case"test":t.processed?(t.falseForkContext.clear(),t.falseForkContext.add(o)):(t.trueForkContext.clear(),t.trueForkContext.add(o));break;case"loop":return t;default:throw new Error("unreachable")}const n=t.trueForkContext;return n.addAll(t.falseForkContext),e.replaceHead(n.makeNext(0,-1)),t}makeLogicalRight(){const t=this.choiceContext,e=this.forkContext;if(t.processed){let o;switch(t.kind){case"&&":o=t.trueForkContext;break;case"||":o=t.falseForkContext;break;case"??":o=t.qqForkContext;break;default:throw new Error("unreachable")}e.replaceHead(o.makeNext(0,-1)),o.clear(),t.processed=!1}else{switch(t.kind){case"&&":t.falseForkContext.add(e.head);break;case"||":t.trueForkContext.add(e.head);break;case"??":t.trueForkContext.add(e.head),t.falseForkContext.add(e.head);break;default:throw new Error("unreachable")}e.replaceHead(e.makeNext(-1,-1))}}makeIfConsequent(){const t=this.choiceContext,e=this.forkContext;t.processed||(t.trueForkContext.add(e.head),t.falseForkContext.add(e.head),t.qqForkContext.add(e.head)),t.processed=!1,e.replaceHead(t.trueForkContext.makeNext(0,-1))}makeIfAlternate(){const t=this.choiceContext,e=this.forkContext;t.trueForkContext.clear(),t.trueForkContext.add(e.head),t.processed=!0,e.replaceHead(t.falseForkContext.makeNext(0,-1))}pushChainContext(){this.chainContext={upper:this.chainContext,countChoiceContexts:0}}popChainContext(){const t=this.chainContext;this.chainContext=t.upper;for(let e=t.countChoiceContexts;e>0;--e)this.popChoiceContext()}makeOptionalNode(){this.chainContext&&(this.chainContext.countChoiceContexts+=1,this.pushChoiceContext("??",!1))}makeOptionalRight(){this.chainContext&&this.makeLogicalRight()}pushSwitchContext(t,e){this.switchContext={upper:this.switchContext,hasCase:t,defaultSegments:null,defaultBodySegments:null,foundDefault:!1,lastIsDefault:!1,countForks:0},this.pushBreakContext(!0,e)}popSwitchContext(){const t=this.switchContext;this.switchContext=t.upper;const e=this.forkContext,o=this.popBreakContext().brokenForkContext;if(0===t.countForks)return void(o.empty||(o.add(e.makeNext(-1,-1)),e.replaceHead(o.makeNext(0,-1))));const n=e.head;this.forkBypassPath();const r=e.head;o.add(n),t.lastIsDefault||(t.defaultBodySegments?(removeConnection(t.defaultSegments,t.defaultBodySegments),makeLooped(this,r,t.defaultBodySegments)):o.add(r));for(let e=0;e<t.countForks;++e)this.forkContext=this.forkContext.upper;this.forkContext.replaceHead(o.makeNext(0,-1))}makeSwitchCaseBody(t,e){const o=this.switchContext;if(!o.hasCase)return;const n=this.forkContext,r=this.pushForkContext();r.add(n.makeNext(0,-1)),e?(o.defaultSegments=n.head,t?o.foundDefault=!0:o.defaultBodySegments=r.head):!t&&o.foundDefault&&(o.foundDefault=!1,o.defaultBodySegments=r.head),o.lastIsDefault=e,o.countForks+=1}pushTryContext(t){this.tryContext={upper:this.tryContext,position:"try",hasFinalizer:t,returnedForkContext:t?ForkContext.newEmpty(this.forkContext):null,thrownForkContext:ForkContext.newEmpty(this.forkContext),lastOfTryIsReachable:!1,lastOfCatchIsReachable:!1}}popTryContext(){const t=this.tryContext;if(this.tryContext=t.upper,"catch"===t.position)return void this.popForkContext();const e=t.returnedForkContext,o=t.thrownForkContext;if(e.empty&&o.empty)return;const n=this.forkContext.head;this.forkContext=this.forkContext.upper;const r=n.slice(0,n.length/2|0),s=n.slice(n.length/2|0);e.empty||getReturnContext(this).returnedForkContext.add(s),o.empty||getThrowContext(this).thrownForkContext.add(s),this.forkContext.replaceHead(r),t.lastOfTryIsReachable||t.lastOfCatchIsReachable||this.forkContext.makeUnreachable()}makeCatchBlock(){const t=this.tryContext,e=this.forkContext,o=t.thrownForkContext;t.position="catch",t.thrownForkContext=ForkContext.newEmpty(e),t.lastOfTryIsReachable=e.reachable,o.add(e.head);const n=o.makeNext(0,-1);this.pushForkContext(),this.forkBypassPath(),this.forkContext.add(n)}makeFinallyBlock(){const t=this.tryContext;let e=this.forkContext;const o=t.returnedForkContext,n=t.thrownForkContext,r=e.head;if("catch"===t.position?(this.popForkContext(),e=this.forkContext,t.lastOfCatchIsReachable=e.reachable):t.lastOfTryIsReachable=e.reachable,t.position="finally",o.empty&&n.empty)return;const s=e.makeNext(-1,-1);for(let t=0;t<e.count;++t){const e=[r[t]];for(let n=0;n<o.segmentsList.length;++n)e.push(o.segmentsList[n][t]);for(let o=0;o<n.segmentsList.length;++o)e.push(n.segmentsList[o][t]);s.push(CodePathSegment.newNext(this.idGenerator.next(),e))}this.pushForkContext(!0),this.forkContext.add(s)}makeFirstThrowablePathInTryBlock(){const t=this.forkContext;if(!t.reachable)return;const e=getThrowContext(this);e!==this&&"try"===e.position&&e.thrownForkContext.empty&&(e.thrownForkContext.add(t.head),t.replaceHead(t.makeNext(-1,-1)))}pushLoopContext(t,e){const o=this.forkContext,n=this.pushBreakContext(!0,e);switch(t){case"WhileStatement":this.pushChoiceContext("loop",!1),this.loopContext={upper:this.loopContext,type:t,label:e,test:void 0,continueDestSegments:null,brokenForkContext:n.brokenForkContext};break;case"DoWhileStatement":this.pushChoiceContext("loop",!1),this.loopContext={upper:this.loopContext,type:t,label:e,test:void 0,entrySegments:null,continueForkContext:ForkContext.newEmpty(o),brokenForkContext:n.brokenForkContext};break;case"ForStatement":this.pushChoiceContext("loop",!1),this.loopContext={upper:this.loopContext,type:t,label:e,test:void 0,endOfInitSegments:null,testSegments:null,endOfTestSegments:null,updateSegments:null,endOfUpdateSegments:null,continueDestSegments:null,brokenForkContext:n.brokenForkContext};break;case"ForInStatement":case"ForOfStatement":this.loopContext={upper:this.loopContext,type:t,label:e,prevSegments:null,leftSegments:null,endOfLeftSegments:null,continueDestSegments:null,brokenForkContext:n.brokenForkContext};break;default:throw new Error(`unknown type: "${t}"`)}}popLoopContext(){const t=this.loopContext;this.loopContext=t.upper;const e=this.forkContext,o=this.popBreakContext().brokenForkContext;switch(t.type){case"WhileStatement":case"ForStatement":this.popChoiceContext(),makeLooped(this,e.head,t.continueDestSegments);break;case"DoWhileStatement":{const n=this.popChoiceContext();n.processed||(n.trueForkContext.add(e.head),n.falseForkContext.add(e.head)),!0!==t.test&&o.addAll(n.falseForkContext);const r=n.trueForkContext.segmentsList;for(let e=0;e<r.length;++e)makeLooped(this,r[e],t.entrySegments);break}case"ForInStatement":case"ForOfStatement":o.add(e.head),makeLooped(this,e.head,t.leftSegments);break;default:throw new Error("unreachable")}o.empty?e.replaceHead(e.makeUnreachable(-1,-1)):e.replaceHead(o.makeNext(0,-1))}makeWhileTest(t){const e=this.loopContext,o=this.forkContext,n=o.makeNext(0,-1);e.test=t,e.continueDestSegments=n,o.replaceHead(n)}makeWhileBody(){const t=this.loopContext,e=this.choiceContext,o=this.forkContext;e.processed||(e.trueForkContext.add(o.head),e.falseForkContext.add(o.head)),!0!==t.test&&t.brokenForkContext.addAll(e.falseForkContext),o.replaceHead(e.trueForkContext.makeNext(0,-1))}makeDoWhileBody(){const t=this.loopContext,e=this.forkContext,o=e.makeNext(-1,-1);t.entrySegments=o,e.replaceHead(o)}makeDoWhileTest(t){const e=this.loopContext,o=this.forkContext;if(e.test=t,!e.continueForkContext.empty){e.continueForkContext.add(o.head);const t=e.continueForkContext.makeNext(0,-1);o.replaceHead(t)}}makeForTest(t){const e=this.loopContext,o=this.forkContext,n=o.head,r=o.makeNext(-1,-1);e.test=t,e.endOfInitSegments=n,e.continueDestSegments=e.testSegments=r,o.replaceHead(r)}makeForUpdate(){const t=this.loopContext,e=this.choiceContext,o=this.forkContext;t.testSegments?finalizeTestSegmentsOfFor(t,e,o.head):t.endOfInitSegments=o.head;const n=o.makeDisconnected(-1,-1);t.continueDestSegments=t.updateSegments=n,o.replaceHead(n)}makeForBody(){const t=this.loopContext,e=this.choiceContext,o=this.forkContext;t.updateSegments?(t.endOfUpdateSegments=o.head,t.testSegments&&makeLooped(this,t.endOfUpdateSegments,t.testSegments)):t.testSegments?finalizeTestSegmentsOfFor(t,e,o.head):t.endOfInitSegments=o.head;let n=t.endOfTestSegments;if(!n){const e=ForkContext.newEmpty(o);e.add(t.endOfInitSegments),t.endOfUpdateSegments&&e.add(t.endOfUpdateSegments),n=e.makeNext(0,-1)}t.continueDestSegments=t.continueDestSegments||n,o.replaceHead(n)}makeForInOfLeft(){const t=this.loopContext,e=this.forkContext,o=e.makeDisconnected(-1,-1);t.prevSegments=e.head,t.leftSegments=t.continueDestSegments=o,e.replaceHead(o)}makeForInOfRight(){const t=this.loopContext,e=this.forkContext,o=ForkContext.newEmpty(e);o.add(t.prevSegments);const n=o.makeNext(-1,-1);t.endOfLeftSegments=e.head,e.replaceHead(n)}makeForInOfBody(){const t=this.loopContext,e=this.forkContext,o=ForkContext.newEmpty(e);o.add(t.endOfLeftSegments);const n=o.makeNext(-1,-1);makeLooped(this,e.head,t.leftSegments),t.brokenForkContext.add(e.head),e.replaceHead(n)}pushBreakContext(t,e){return this.breakContext={upper:this.breakContext,breakable:t,label:e,brokenForkContext:ForkContext.newEmpty(this.forkContext)},this.breakContext}popBreakContext(){const t=this.breakContext,e=this.forkContext;if(this.breakContext=t.upper,!t.breakable){const o=t.brokenForkContext;o.empty||(o.add(e.head),e.replaceHead(o.makeNext(0,-1)))}return t}makeBreak(t){const e=this.forkContext;if(!e.reachable)return;const o=getBreakContext(this,t);o&&o.brokenForkContext.add(e.head),e.replaceHead(e.makeUnreachable(-1,-1))}makeContinue(t){const e=this.forkContext;if(!e.reachable)return;const o=getContinueContext(this,t);o&&(o.continueDestSegments?(makeLooped(this,e.head,o.continueDestSegments),"ForInStatement"!==o.type&&"ForOfStatement"!==o.type||o.brokenForkContext.add(e.head)):o.continueForkContext.add(e.head)),e.replaceHead(e.makeUnreachable(-1,-1))}makeReturn(){const t=this.forkContext;t.reachable&&(getReturnContext(this).returnedForkContext.add(t.head),t.replaceHead(t.makeUnreachable(-1,-1)))}makeThrow(){const t=this.forkContext;t.reachable&&(getThrowContext(this).thrownForkContext.add(t.head),t.replaceHead(t.makeUnreachable(-1,-1)))}makeFinal(){const t=this.currentSegments;t.length>0&&t[0].reachable&&this.returnedForkContext.add(t)}}module.exports=CodePathState;
//# sourceMappingURL=/sm/9c6ef67742d6c8286517aca75a90a49107b74a6cffc490a6cbcbb277903e2f3a.map