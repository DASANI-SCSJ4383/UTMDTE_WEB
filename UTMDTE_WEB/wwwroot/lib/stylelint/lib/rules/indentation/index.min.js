/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/stylelint@14.6.0/lib/rules/indentation/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
"use strict";const beforeBlockString=require("../../utils/beforeBlockString"),hasBlock=require("../../utils/hasBlock"),optionsMatches=require("../../utils/optionsMatches"),report=require("../../utils/report"),ruleMessages=require("../../utils/ruleMessages"),styleSearch=require("style-search"),validateOptions=require("../../utils/validateOptions"),{isAtRule:isAtRule,isDeclaration:isDeclaration,isRoot:isRoot,isRule:isRule}=require("../../utils/typeGuards"),{isBoolean:isBoolean,isNumber:isNumber,isString:isString}=require("../../utils/validateTypes"),ruleName="indentation",messages=ruleMessages(ruleName,{expected:e=>`Expected indentation of ${e}`}),meta={url:"https://stylelint.io/user-guide/rules/list/indentation"},rule=(e,t={},n)=>(r,s)=>{if(!validateOptions(s,ruleName,{actual:e,possible:[isNumber,"tab"]},{actual:t,possible:{baseIndentLevel:[isNumber,"auto"],except:["block","value","param"],ignore:["value","param","inside-parens"],indentInsideParens:["twice","once-at-root-twice-in-block"],indentClosingBrace:[isBoolean]},optional:!0}))return;const o=isNumber(e)?e:null,a=null==o?"\t":" ".repeat(o),i="tab"===e?"tab":"space",c=t.baseIndentLevel,l=t.indentClosingBrace,u=e=>{const t=null==o?e:e*o;return`${t} ${1===t?i:`${i}s`}`};function d(n,r=0){if(!n.parent)throw new Error("A parent node must be present");if(isRoot(n.parent))return r+getRootBaseIndentLevel(n.parent,c,e);let s;return s=d(n.parent,r+1),optionsMatches(t,"except","block")&&(isRule(n)||isAtRule(n))&&hasBlock(n)&&s--,s}function f(e,r,o){if(!e.includes("\n"))return;const i=[];let c=0;const d=optionsMatches(t,"ignore","inside-parens");if(styleSearch({source:e,target:"\n",outsideParens:d},((f,p)=>{const m=/^[ \t]*\)/.test(e.slice(f.startIndex+1));if(d&&(m||f.insideParens))return;let h=r;if(!d&&f.insideParens){1===p&&(c-=1);let n=f.startIndex;"\r"===e[f.startIndex-1]&&n--;/\([ \t]*$/.test(e.slice(0,n))&&(c+=1);/\{[ \t]*$/.test(e.slice(0,n))&&(c+=1);switch(/^[ \t]*\}/.test(e.slice(f.startIndex+1))&&(c-=1),h+=c,m&&(c-=1),t.indentInsideParens){case"twice":m&&!l||(h+=1);break;case"once-at-root-twice-in-block":if(o.parent===o.root()){m&&!l&&(h-=1);break}m&&!l||(h+=1);break;default:m&&!l&&(h-=1)}}const g=/^([ \t]*)\S/.exec(e.slice(f.startIndex+1));if(!g)return;const I=g[1],w=a.repeat(h>0?h:0);I!==w&&(n.fix?i.unshift({expectedIndentation:w,currentIndentation:I,startIndex:f.startIndex}):report({message:messages.expected(u(h)),node:o,index:f.startIndex+I.length+1,result:s,ruleName:ruleName}))})),i.length){if(isRule(o))for(const e of i)o.selector=replaceIndentation(o.selector,e.currentIndentation,e.expectedIndentation,e.startIndex);if(isDeclaration(o)){const e=o.prop,t=o.raws.between;if(!isString(t))throw new TypeError("The `between` property must be a string");for(const n of i)n.startIndex<e.length+t.length?o.raws.between=replaceIndentation(t,n.currentIndentation,n.expectedIndentation,n.startIndex-e.length):o.value=replaceIndentation(o.value,n.currentIndentation,n.expectedIndentation,n.startIndex-e.length-t.length)}if(isAtRule(o)){const e=o.name,t=o.raws.afterName,n=o.params;if(!isString(t))throw new TypeError("The `afterName` property must be a string");for(const r of i)r.startIndex<1+e.length+t.length?o.raws.afterName=replaceIndentation(t,r.currentIndentation,r.expectedIndentation,r.startIndex-e.length-1):o.params=replaceIndentation(n,r.currentIndentation,r.expectedIndentation,r.startIndex-e.length-t.length-1)}}}r.walk((e=>{if(isRoot(e))return;const r=d(e),o=(e.raws.before||"").replace(/[*_]$/,""),i="string"==typeof e.raws.after?e.raws.after:"",c=e.parent;if(!c)throw new Error("A parent node must be present");const p=a.repeat(r),m="root"===c.type&&c.first===e,h=o.lastIndexOf("\n");(-1!==h||m&&(!getDocument(c)||c.raws.codeBefore&&c.raws.codeBefore.endsWith("\n")))&&o.slice(h+1)!==p&&(n.fix?(m&&isString(e.raws.before)&&(e.raws.before=e.raws.before.replace(/^[ \t]*(?=\S|$)/,p)),e.raws.before=fixIndentation(e.raws.before,p)):report({message:messages.expected(u(r)),node:e,result:s,ruleName:ruleName}));const g=l?r+1:r,I=a.repeat(g);(isRule(e)||isAtRule(e))&&hasBlock(e)&&i&&i.includes("\n")&&i.slice(i.lastIndexOf("\n")+1)!==I&&(n.fix?e.raws.after=fixIndentation(e.raws.after,I):report({message:messages.expected(u(g)),node:e,index:e.toString().length-1,result:s,ruleName:ruleName})),isDeclaration(e)&&function(e,n){if(!e.value.includes("\n"))return;if(optionsMatches(t,"ignore","value"))return;const r=e.toString(),s=optionsMatches(t,"except","value")?n:n+1;f(r,s,e)}(e,r),isRule(e)&&function(e,t){const n=e.selector;e.params&&(t+=1);f(n,t,e)}(e,r),isAtRule(e)&&function(e,n){if(optionsMatches(t,"ignore","param"))return;const r=optionsMatches(t,"except","param")||"nest"===e.name||"at-root"===e.name?n:n+1;f(beforeBlockString(e).trim(),r,e)}(e,r)}))};function getRootBaseIndentLevel(e,t,n){const r=getDocument(e);if(!r)return 0;if(!e.source)throw new Error("The root node must have a source");const s=e.source,o=s.baseIndentLevel;if(isNumber(o)&&Number.isSafeInteger(o))return o;const a=inferRootIndentLevel(e,t,(()=>inferDocIndentSize(r,n)));return s.baseIndentLevel=a,a}function getDocument(e){const t=e.document;if(t)return t;const n=e.root();return n&&n.document}function inferDocIndentSize(e,t){if(!e.source)throw new Error("The document node must have a source");const n=e.source;let r=n.indentSize;if(isNumber(r)&&Number.isSafeInteger(r))return r;const s=e.source.input.css.match(/^ *(?=\S)/gm);if(s){const e=new Map;let t=0,n=0;const o=r=>{if(r){if(t=Math.abs(r-n)||t,t>1){const n=e.get(t);n?e.set(t,n+1):e.set(t,1)}}else t=0;n=r};for(const e of s)o(e.length);let a=0;for(const[t,n]of e.entries())n>a&&(a=n,r=t)}return r=Number(r)||s&&s[0].length||Number(t)||2,n.indentSize=r,r}function inferRootIndentLevel(e,t,n){function r(e){const t=e.match(/\t/g),r=t?t.length:0,s=e.match(/ /g);return r+(s?Math.round(s.length/n()):0)}let s=0;if(isNumber(t)&&Number.isSafeInteger(t))s=t;else{if(!e.source)throw new Error("The root node must have a source");let t=e.source.input.css;t=t.replace(/^[^\r\n]+/,(t=>{const n=e.raws.codeBefore&&/(?:^|\n)([ \t]*)$/.exec(e.raws.codeBefore);return n?n[1]+t:""}));const n=t.match(/^[ \t]*(?=\S)/gm);if(n)return Math.min(...n.map((e=>r(e))));s=1}const o=[],a=e.raws.codeBefore&&/(?:^|\n)([ \t]*)\S/m.exec(e.raws.codeBefore);if(a){let e=Number.MAX_SAFE_INTEGER,t=0;for(;++t<a.length;){const n=r(a[t]);if(n<e&&(e=n,0===e))break}e!==Number.MAX_SAFE_INTEGER&&o.push(new Array(e).fill(" ").join(""))}const i=e.raws.after;if(i){let t;if(i.endsWith("\n")){const n=e.document;if(n){const r=n.nodes[n.nodes.indexOf(e)+1];t=r?r.raws.codeBefore:n.raws.codeAfter}else{const n=e.parent;if(!n)throw new Error("The root node must have a parent");const r=n.nodes[n.nodes.indexOf(e)+1];t=r?r.raws.codeBefore:e.raws.codeAfter}}else t=i;t&&o.push(t.match(/^[ \t]*/)[0])}return o.length?Math.max(...o.map((e=>r(e))))+s:s}function fixIndentation(e,t){return isString(e)?e.replace(/\n[ \t]*(?=\S|$)/g,`\n${t}`):e}function replaceIndentation(e,t,n,r){const s=r+1;return e.slice(0,s)+n+e.slice(s+t.length)}rule.ruleName=ruleName,rule.messages=messages,rule.meta=meta,module.exports=rule;
//# sourceMappingURL=/sm/193e8167673888c8d7d8573da73653403db2a699ea490c8491f1ec583a98c74b.map