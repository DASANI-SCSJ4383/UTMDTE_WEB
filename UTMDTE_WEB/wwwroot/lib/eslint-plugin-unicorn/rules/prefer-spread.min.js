/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/eslint-plugin-unicorn@41.0.1/rules/prefer-spread.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
"use strict";const{isParenthesized:isParenthesized,getStaticValue:getStaticValue,isCommaToken:isCommaToken,hasSideEffect:hasSideEffect}=require("eslint-utils"),{methodCallSelector:methodCallSelector,not:not}=require("./selectors/index.js"),needsSemicolon=require("./utils/needs-semicolon.js"),{getParenthesizedRange:getParenthesizedRange,getParenthesizedText:getParenthesizedText}=require("./utils/parentheses.js"),shouldAddParenthesesToSpreadElementArgument=require("./utils/should-add-parentheses-to-spread-element-argument.js"),isLiteralValue=require("./utils/is-literal-value.js"),{isNodeMatches:isNodeMatches}=require("./utils/is-node-matches.js"),{replaceNodeOrTokenAndSpacesBefore:replaceNodeOrTokenAndSpacesBefore,removeSpacesAfter:removeSpacesAfter,removeMethodCall:removeMethodCall}=require("./fix/index.js"),ERROR_ARRAY_FROM="array-from",ERROR_ARRAY_CONCAT="array-concat",ERROR_ARRAY_SLICE="array-slice",ERROR_STRING_SPLIT="string-split",SUGGESTION_CONCAT_ARGUMENT_IS_SPREADABLE="argument-is-spreadable",SUGGESTION_CONCAT_ARGUMENT_IS_NOT_SPREADABLE="argument-is-not-spreadable",SUGGESTION_CONCAT_TEST_ARGUMENT="test-argument",SUGGESTION_CONCAT_SPREAD_ALL_ARGUMENTS="spread-all-arguments",SUGGESTION_USE_SPREAD="use-spread",messages={"array-from":"Prefer the spread operator over `Array.from(…)`.","array-concat":"Prefer the spread operator over `Array#concat(…)`.","array-slice":"Prefer the spread operator over `Array#slice()`.","string-split":"Prefer the spread operator over `String#split('')`.","argument-is-spreadable":"First argument is an `array`.","argument-is-not-spreadable":"First argument is not an `array`.","test-argument":"Test first argument with `Array.isArray(…)`.","spread-all-arguments":"Spread all unknown arguments`.","use-spread":"Use `...` operator."},arrayFromCallSelector=[methodCallSelector({object:"Array",method:"from",minimumArguments:1,maximumArguments:3}),'[arguments.0.type!="ObjectExpression"]'].join(""),arrayConcatCallSelector=[methodCallSelector("concat"),not(["Literal","TemplateLiteral"].map((e=>`[callee.object.type="${e}"]`)))].join(""),arraySliceCallSelector=[methodCallSelector({method:"slice",minimumArguments:0,maximumArguments:1}),'[callee.object.type!="ArrayExpression"]'].join(""),ignoredSliceCallee=["arrayBuffer","blob","buffer","file","this"],stringSplitCallSelector=methodCallSelector({method:"split",argumentsLength:1}),isArrayLiteral=e=>"ArrayExpression"===e.type,isArrayLiteralHasTrailingComma=(e,r)=>0!==e.elements.length&&isCommaToken(r.getLastToken(e,1));function fixConcat(e,r,t){const a=e.callee.object,s=e.arguments,n=getParenthesizedRange(a,r),o=isArrayLiteral(a),i=o&&isArrayLiteralHasTrailingComma(a,r),l=()=>{const e=t.filter((({node:e,isArrayLiteral:r})=>!r||e.elements.length>0)),s=e[e.length-1];let n=e.map((({node:e,isArrayLiteral:t,isSpreadable:a,testArgument:n})=>{if(t)return((e,t)=>{if(!t&&isArrayLiteralHasTrailingComma(e,r)){const t=e.range[0]+1,a=r.getLastToken(e,1).range[0];return r.text.slice(t,a)}return r.getText(e,-1,-1)})(e,e===s.node);let o=getParenthesizedText(e,r);return n?`...(Array.isArray(${o}) ? ${o} : [${o}])`:(a&&(!isParenthesized(e,r)&&shouldAddParenthesesToSpreadElementArgument(e)&&(o=`(${o})`),o=`...${o}`),o||" ")})).join(", ");return n?(o?a.elements.length>0&&(n=` ${n}`,i||(n=`,${n}`),!i||s.isArrayLiteral&&isArrayLiteralHasTrailingComma(s.node,r)||(n=`${n},`)):n=`, ${n}`,n):""};return function*(i){!o&&needsSemicolon(r.getTokenBefore(e),r,"[")&&(yield i.insertTextBefore(e,";")),s.length-t.length==0?yield*removeMethodCall(i,e,r):yield function(e){const[a]=s,n=s[t.length-1],[o]=getParenthesizedRange(a,r);let[,i]=r.getTokenAfter(n,isCommaToken).range;const l=r.text.slice(i),[c]=l.match(/^\s*/);return i+=c.length,e.replaceTextRange([o,i],"")}(i);const c=l();if(o){const e=r.getLastToken(a);yield i.insertTextBefore(e,c)}else yield i.insertTextBeforeRange(n,"[..."),yield i.insertTextAfterRange(n,c),yield i.insertTextAfterRange(n,"]")}}const getConcatArgumentSpreadable=(e,r)=>{if("SpreadElement"===e.type)return;if(isArrayLiteral(e))return{node:e,isArrayLiteral:!0};const t=getStaticValue(e,r);if(!t)return;return{node:e,isSpreadable:Array.isArray(t.value)}};function getConcatFixableArguments(e,r){const t=[];for(const a of e){const e=getConcatArgumentSpreadable(a,r);if(!e)break;t.push(e)}return t}function fixArrayFrom(e,r){const[t]=e.arguments;return function*(a){needsSemicolon(r.getTokenBefore(e),r,"[")&&(yield a.insertTextBefore(e,";"));const s=function(){if(isArrayLiteral(t))return r.getText(t);const[e,a]=getParenthesizedRange(t,r);let s=r.text.slice(e,a);return!isParenthesized(t,r)&&shouldAddParenthesesToSpreadElementArgument(t)&&(s=`(${s})`),`[...${s}]`}();1!==e.arguments.length?(yield a.replaceText(e.callee.object,s),yield a.replaceText(e.callee.property,"map"),yield*function*(e){yield*replaceNodeOrTokenAndSpacesBefore(t,"",e,r);const a=r.getTokenAfter(t,isCommaToken);yield*replaceNodeOrTokenAndSpacesBefore(a,"",e,r),yield removeSpacesAfter(a,r,e)}(a)):yield a.replaceText(e,s)}}function methodCallToSpread(e,r){return function*(t){needsSemicolon(r.getTokenBefore(e),r,"[")&&(yield t.insertTextBefore(e,";")),yield t.insertTextBefore(e,"[..."),yield t.insertTextAfter(e,"]"),yield*removeMethodCall(t,e,r)}}function isClassName(e){if("MemberExpression"===e.type&&(e=e.property),"Identifier"!==e.type)return!1;const{name:r}=e;return/^[A-Z]./.test(r)&&r.toUpperCase()!==r}const create=e=>{const r=e.getSourceCode();return{[arrayFromCallSelector]:e=>({node:e,messageId:"array-from",fix:fixArrayFrom(e,r)}),[arrayConcatCallSelector](t){const{object:a}=t.callee;if(isClassName(a))return;const s=e.getScope(),n=getStaticValue(a,s);if(n&&!Array.isArray(n.value))return;const o={node:t.callee.property,messageId:"array-concat"},i=getConcatFixableArguments(t.arguments,s);if(i.length>0||0===t.arguments.length)return o.fix=fixConcat(t,r,i),o;const[l,...c]=t.arguments;if("SpreadElement"===l.type)return o;const d=getConcatFixableArguments(c,s),m=[{messageId:"argument-is-spreadable",isSpreadable:!0},{messageId:"argument-is-not-spreadable",isSpreadable:!1}];return hasSideEffect(l,r)||m.push({messageId:"test-argument",testArgument:!0}),o.suggest=m.map((({messageId:e,isSpreadable:a,testArgument:s})=>({messageId:e,fix:fixConcat(t,r,[{node:l,isSpreadable:a,testArgument:s},...d])}))),d.length<c.length&&c.every((({type:e})=>"SpreadElement"!==e))&&o.suggest.push({messageId:"spread-all-arguments",fix:fixConcat(t,r,t.arguments.map((e=>getConcatArgumentSpreadable(e,s)||{node:e,isSpreadable:!0})))}),o},[arraySliceCallSelector](e){if(isNodeMatches(e.callee.object,ignoredSliceCallee))return;const[t]=e.arguments;return!t||isLiteralValue(t,0)?{node:e.callee.property,messageId:"array-slice",fix:methodCallToSpread(e,r)}:void 0},[stringSplitCallSelector](t){const[a]=t.arguments;if(!isLiteralValue(a,""))return;const s=t.callee.object,n=getStaticValue(s,e.getScope());let o=!1;if(n){const{value:e}=n;if("string"!=typeof e)return;const r=e.split(""),t=[...e];o=r.length===t.length&&r.every(((e,r)=>e===t[r]))}const i={node:t.callee.property,messageId:"string-split"};return o?i.fix=methodCallToSpread(t,r):i.suggest=[{messageId:"use-spread",fix:methodCallToSpread(t,r)}],i}}};module.exports={create:create,meta:{type:"suggestion",docs:{description:"Prefer the spread operator over `Array.from(…)`, `Array#concat(…)`, `Array#slice()` and `String#split('')`."},fixable:"code",hasSuggestions:!0,messages:messages}};
//# sourceMappingURL=/sm/06f9fc4ed2b6a9b10c4c69ea9e555287c11eeb48c240ea35b6da8d5231a5cc01.map