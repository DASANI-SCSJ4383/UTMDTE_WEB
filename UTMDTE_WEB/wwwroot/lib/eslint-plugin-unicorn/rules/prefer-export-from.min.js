/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/eslint-plugin-unicorn@41.0.1/rules/prefer-export-from.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
"use strict";const{isCommaToken:isCommaToken,isOpeningBraceToken:isOpeningBraceToken,isClosingBraceToken:isClosingBraceToken}=require("eslint-utils"),MESSAGE_ID_ERROR="error",MESSAGE_ID_SUGGESTION="suggestion",messages={error:"Use `export…from` to re-export `{{exported}}`.",suggestion:"Switch to `export…from`."},DEFAULT_SPECIFIER_NAME=Symbol.for("default"),NAMESPACE_SPECIFIER_NAME=Symbol("NAMESPACE_SPECIFIER_NAME"),getSpecifierName=e=>{switch(e.type){case"Identifier":return Symbol.for(e.name);case"Literal":return e.value}},isTypeExport=e=>"type"===e.exportKind||"type"===e.parent.exportKind,isTypeImport=e=>"type"===e.importKind||"type"===e.parent.importKind;function*removeSpecifier(e,t,r){const{parent:o}=e,{specifiers:i}=o;if(1!==i.length)switch(e.type){case"ImportSpecifier":if(!i.some((t=>t!==e&&t.type===e.type))){const o=r.getTokenAfter(e,isClosingBraceToken),i=r.getTokenBefore(e,isCommaToken);return void(yield t.replaceTextRange([i.range[0],o.range[1]],""))}case"ExportSpecifier":case"ImportNamespaceSpecifier":case"ImportDefaultSpecifier":{yield t.remove(e);const o=r.getTokenAfter(e);isCommaToken(o)&&(yield t.remove(o));break}}else yield*removeImportOrExport(o,t,r)}function*removeImportOrExport(e,t,r){switch(e.type){case"ImportSpecifier":case"ExportSpecifier":case"ImportDefaultSpecifier":case"ImportNamespaceSpecifier":return void(yield*removeSpecifier(e,t,r));case"ImportDeclaration":case"ExportDefaultDeclaration":case"ExportNamedDeclaration":yield t.remove(e)}}function getSourceAndAssertionsText(e,t){const r=t.getTokenBefore(e.source,(e=>"Identifier"===e.type&&"from"===e.value)),[o]=r.range,[,i]=e.range;return t.text.slice(o,i)}function getFixFunction({sourceCode:e,imported:t,exported:r,exportDeclarations:o,program:i}){const n=t.declaration,s=n.source.value,a=t.isTypeImport||r.isTypeExport;let p;return a&&(p=o.find((({source:e,exportKind:t})=>e.value===s&&"type"===t))),p||(p=o.find((({source:e,exportKind:t})=>e.value===s&&"type"!==t))),function*(o){if(t.name===NAMESPACE_SPECIFIER_NAME)yield o.insertTextAfter(i,`\nexport * as ${r.text} ${getSourceAndAssertionsText(n,e)}`);else{let s=r.name===t.name?r.text:`${t.text} as ${r.text}`;if(!a||p&&"type"===p.exportKind||(s=`type ${s}`),p){const t=p.specifiers[p.specifiers.length-1];if(t)yield o.insertTextAfter(t,`, ${s}`);else{const t=e.getFirstToken(p,isOpeningBraceToken);yield o.insertTextAfter(t,s)}}else yield o.insertTextAfter(i,`\nexport {${s}} ${getSourceAndAssertionsText(n,e)}`)}1===t.variable.references.length&&(yield*removeImportOrExport(t.node,o,e)),yield*removeImportOrExport(r.node,o,e)}}function getExported(e,t,r){const{parent:o}=e;switch(o.type){case"ExportDefaultDeclaration":return{node:o,name:DEFAULT_SPECIFIER_NAME,text:"default",isTypeExport:isTypeExport(o)};case"ExportSpecifier":return{node:o,name:getSpecifierName(o.exported),text:r.getText(o.exported),isTypeExport:isTypeExport(o)};case"VariableDeclarator":if(o.init===e&&"Identifier"===o.id.type&&!o.id.typeAnnotation&&"VariableDeclaration"===o.parent.type&&"const"===o.parent.kind&&1===o.parent.declarations.length&&o.parent.declarations[0]===o&&"ExportNamedDeclaration"===o.parent.parent.type&&isVariableUnused(o,t))return{node:o.parent.parent,name:Symbol.for(o.id.name),text:r.getText(o.id)}}}function isVariableUnused(e,t){const r=t.getDeclaredVariables(e);if(1!==r.length)return!1;const[{identifiers:o,references:i}]=r;return 1===o.length&&o[0]===e.id&&1===i.length&&i[0].identifier===e.id}function getImported(e,t){const r=e.defs[0].node,o={node:r,declaration:r.parent,variable:e,isTypeImport:isTypeImport(r)};switch(r.type){case"ImportDefaultSpecifier":return{name:DEFAULT_SPECIFIER_NAME,text:"default",...o};case"ImportSpecifier":return{name:getSpecifierName(r.imported),text:t.getText(r.imported),...o};case"ImportNamespaceSpecifier":return{name:NAMESPACE_SPECIFIER_NAME,text:"*",...o}}}function getExports(e,t,r){const o=[];for(const{identifier:i}of e.variable.references){const n=getExported(i,t,r);n&&(e.name===NAMESPACE_SPECIFIER_NAME&&n.name===DEFAULT_SPECIFIER_NAME||o.push(n))}return o}const schema=[{type:"object",additionalProperties:!1,properties:{ignoreUsedVariables:{type:"boolean",default:!1}}}];function create(e){const t=e.getSourceCode(),{ignoreUsedVariables:r}={ignoreUsedVariables:!1,...e.options[0]},o=new Set,i=[];return{"ImportDeclaration[specifiers.length>0]"(e){o.add(e)},'ExportNamedDeclaration[source.type="Literal"]'(e){i.push(e)},*"Program:exit"(n){for(const s of o){let o=e.getDeclaredVariables(s);if(o.some((e=>1!==e.defs.length||e.defs[0].parent!==s)))continue;if(o=o.map((r=>{const o=getImported(r,t);return{variable:r,imported:o,exports:getExports(o,e,t)}})),r&&o.some((({variable:e,exports:t})=>e.references.length!==t.length)))continue;const a=r&&o.some((({variable:e})=>0===e.references.length));for(const{imported:e,exports:r}of o)for(const o of r){const r={node:o.node,messageId:"error",data:{exported:o.text}},s=getFixFunction({sourceCode:t,imported:e,exported:o,exportDeclarations:i,program:n});a?r.suggest=[{messageId:"suggestion",fix:s}]:r.fix=s,yield r}}}}}module.exports={create:create,meta:{type:"suggestion",docs:{description:"Prefer `export…from` when re-exporting."},fixable:"code",hasSuggestions:!0,schema:schema,messages:messages}};
//# sourceMappingURL=/sm/578bb8b208a441e03297228a7f82e2916df90d0dda1b9ef830a15f40e36215f4.map